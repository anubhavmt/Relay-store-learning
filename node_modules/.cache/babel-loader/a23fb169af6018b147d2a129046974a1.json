{"ast":null,"code":"var _ApprootQuery,\n    _ApprootupdateBookQuery,\n    _jsxFileName = \"/Users/anubhavgupta/Documents/react_learning/graphql-react/relay-store-learning/src/Approot.tsx\",\n    _s = $RefreshSig$();\n\nimport React from \"react\";\nimport App from \"./App\";\nimport { useLazyLoadQuery, useMutation, useRelayEnvironment } from \"react-relay/hooks\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst appquery = _ApprootQuery !== void 0 ? _ApprootQuery : (_ApprootQuery = require(\"./__generated__/ApprootQuery.graphql\"), _ApprootQuery.hash && _ApprootQuery.hash !== \"867372aaae776ea7a106594d996912b5\" && console.error(\"The definition of 'ApprootQuery' appears to have changed. Run `relay-compiler` to update the generated files to receive the expected data.\"), _ApprootQuery);\nconst appMutateupdatequery = _ApprootupdateBookQuery !== void 0 ? _ApprootupdateBookQuery : (_ApprootupdateBookQuery = require(\"./__generated__/ApprootupdateBookQuery.graphql\"), _ApprootupdateBookQuery.hash && _ApprootupdateBookQuery.hash !== \"a434ac08907ae5df34adf95d93b1e470\" && console.error(\"The definition of 'ApprootupdateBookQuery' appears to have changed. Run `relay-compiler` to update the generated files to receive the expected data.\"), _ApprootupdateBookQuery);\n\nfunction Approot(props) {\n  _s();\n\n  const [commitupdate] = useMutation(appMutateupdatequery);\n  const data = useLazyLoadQuery(appquery, {}, {\n    fetchPolicy: 'store-or-network'\n  }); // console.log(\"approot......\")\n  // console.log(data);\n  // .........................................Let's go for learning useRelayEnvironment return type , so that can be used some where else also\n  // Aim get RecordProxy that's it\n  // some says that this is used by relay it self to managed , so not recommend to use this. always use with update etc. but hume to kar na hai\n\n  const storeEnv = useRelayEnvironment().getStore();\n  console.log(\".......................Not Understandable.......useRelayEnvironment().getStore(),   type: RelayModernStore\");\n  console.log(storeEnv);\n  console.log(\"......................Not Understandable........useRelayEnvironment().getStore().getSource(),   type: RelayModernStore\");\n  console.log(storeEnv.getSource());\n  console.log(\"...........These are the useful function for use...............\");\n  console.log(\"..............................useRelayEnvironment().getStore().getSource().getRecordIDs()\");\n  /*\n   return the list of ids which we use in store (referring to store which we get in updated)\n  store.get(\"\") \n  */\n\n  console.log(storeEnv.getSource().getRecordIDs()); // use to get the data for the id store.get(\"1\")\n\n  console.log(storeEnv.getSource().get(\"1\")); // can assume this as RecordProxy\n  // refer: to deal with object in js \n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\n\n  const idObject = storeEnv.getSource().get(\"1\"); // type object \n\n  console.log(idObject); // console.log(Object.keys(idObject))\n\n  /*\n   The useRelayEnvironment().getStore() function returns a Store object from the Relay Modern library. The type of object returned depends on the method called on the Store object.\n   Calling getStore().getSource() returns a RecordSource object, which is an interface for reading and writing records in the store.\n   Calling getStore().getSource().get(<dataID>) returns a RecordProxy object, which is a mutable interface for a single record in the store with the specified dataID.\n   Calling getStore().getSource().get(<selector>) returns a RecordSourceSelectorProxy object, which is a mutable interface for a set of records in the store that match the specified selector.\n   So, depending on which method is called on the Store object, the returned type could be either a RecordProxy or a RecordSourceSelectorProxy.\n  \n   RelayModernStore is a central store for managing the data cache of a Relay application, \n  while RelayRecordSourceSelectorProxy is a lower-level API for reading from and writing to\n  specific pieces of data in the store.\n    The type of the store variable obtained from environment.getStore() is RelayModernStore. \n  The RelayModernStore is the central class in Relay that manages the cache of records, \n  and is responsible for reading and writing data to the cache. It is not a RecordSourceSelectorProxy \n  or RecordProxy, but it provides methods to interact with those objects.\n   You can use the RelayModernStore object to get a RecordSourceSelectorProxy using the getSource\n  method, which returns a RelayRecordSourceSelectorProxy. For example, to read data from the \n  cache using a RelayRecordSourceSelectorProxy, you can use the following code:\n    const store = environment.getStore();\n  const source = store.getSource();\n  const user = source.get('123');\n  console.log(user.getValue('name')); // Logs the name of the user record with ID '123'\n  \n  In this example, we get the RelayModernStore from the RelayModernEnvironment, \n  and use the getSource method to get a RelayRecordSourceSelectorProxy. We then use the get \n  method to get the user record with ID '123', and use the getValue method to read the value of\n   the name field on the user record.\n  \n    Normalized Relay Store  --> object with id \n   Flattened Relay Store  --> with client prefix\n    how does it works ? \n  \n  */\n\n  return /*#__PURE__*/_jsxDEV(React.Suspense, {\n    fallback: /*#__PURE__*/_jsxDEV(\"div\", {\n      children: \"Loading.....\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 170,\n      columnNumber: 31\n    }, this),\n    children: [/*#__PURE__*/_jsxDEV(App, {\n      books: data.books[0]\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 171,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"form\", {\n      className: \"form\",\n      onSubmit: e => {\n        e.preventDefault();\n        let update = {\n          id: e.target[0].value,\n          book: {\n            id: e.target[0].value,\n            title: e.target[1].value,\n            author: {\n              id: e.target[2].value,\n              firstname: e.target[3].value,\n              secondname: e.target[4].value\n            }\n          }\n        };\n        commitupdate({\n          variables: update,\n          onCompleted: (response, errors) => {\n            console.log(\"Response received from server.\");\n          },\n          updater: store => {\n            console.log(\"in mutaiton\");\n            console.log(\"Type: RelayRecordSourceSelectorProxy\"); // Doc: https://relay.dev/docs/api-reference/store/#recordsourceselectorproxy\n\n            /*\n               interface RecordSourceSelectorProxy {\n               create(dataID: string, typeName: string): RecordProxy;\n               ->Creates a new record in the store given a dataID and the typeName(type Book so this book is typename) as defined by the GraphQL schema \n              \n              .............................................................................................\n              \n              delete(dataID: string): void;\n               -> same like create\n               .............................................................................................\n               get(dataID: string): ?RecordProxy;\n               .............................................................................................\n               getRoot(): RecordProxy;\n               -> Returns the RecordProxy representing the root of the GraphQL document.\n                .............................................................................................\n                getRootField(fieldName: string): ?RecordProxy;\n               -> Typings: \n              getRootField<K extends keyof T>(fieldName: K): RecordProxy<NonNullable<T[K]>>;\n               This method also allows you to fetch records from the store. How is this different \n              from the getRoot method? They differ in scope and use. While getRoot can get data \n              from the entire store, getRootField cannot. It can only get the data corresponding \n              to the concerned operation (the operation that invoked the updater function).\n               For example, consider the updateUser mutation:\n               mutation UpdateUserMutation{\n                updateUser(id: \"ANOTHERUSER1\", newName: \"Random Name\"){\n                  id\n                  name\n                }\n              }\n              This results in following GraphQL document:\n               updateUser(id: \"ANOTHERUSER1\", newName: \"Random Name\"){\n                id\n                name\n              }\n              getRootField can get data from this document only. But the good thing is \n              that since this was made for small documents, you can directly get the records \n              — without binding arguments to the field.\n               const payload = store.getRootField(\"updateUser\");\n              You can use the RecordProxy to access the payload of the mutation.\n               .............................................................................................\n               getPluralRootField(fieldName: string): ?Array<?RecordProxy>;\n                getRootField cannot get mutliple records. For such cases, we have the getPluralRootField method. So if the operation returns a collection of GraphQL objects instead of a single object, we use this method. What if the operation returned a Scalar or an array of Scalars? In that case, they won’t be stored in the store as the operation payload did not obey Global Object Identification. Moving on, Consider the generateQuestions mutation:\n               mutation GenerateQuestionsMutation{\n              # generate n random questions\n              # generateQuestions(n: Int!): [Question!]!\n                generateQuestions(n: 10){\n                  id\n                  description\n                }\n              }\n              This results in following GraphQL document:\n               generateQuestions(n: 10){\n                # Returns 10 randomly generated questions\n                id\n                description\n              }\n              If I try to use store.getRootField(\"generateUsers\") , \n              it won’t work as generateQuestions returns an array of Users . \n              Instead, I need to do\n               const payload = store.getRootPluralField(\"generateQuestions\");\n              The payload will contain the array of Questions (RecordProxy of type Question) .\n              \n              You can then access it like a normal array\n               const descriptions = payload.map(question => question.getValue(\"description\"));\n               .............................................................................................\n               invalidateStore(): void;\n                Globally invalidates the Relay store. This will cause any data that was written to the\n              store before invalidation occurred to be considered stale, and will be considered to\n              require refetch the next time a query is checked with environment.check().\n               Example\n              store.invalidateStore();\n               After global invalidation, any query that is checked before refetching it will be \n              considered stale:\n               environment.check(query) === 'stale'\n              */\n            // create\n            // const manualdata = store.create(\"anubhav|122\", \"manual\")\n            // console.log(store);\n            // console.log(\"............................store.get(1)\")\n            // console.log(store.get(\"1\"));\n            // console.log(\"............................store.get(client:root)\")\n            // console.log(store.get(\"client:root\"));\n            // console.log(\"............................store.get(3)\")\n            // console.log(store.get(\"3\"));\n            // console.log(\"............................store.get(wrong)\")\n            // console.log(store.get(\"wrong\")); // will get undefined\n            // console.log(\"............................store.getRoot()\")\n            // console.log(store.getRoot());\n            // //getRootField\n            // console.log(\"............................store.getRootField()\")    \n            // console.log(store.getRootField('updateBook'));\n            // (window as any).store = store;\n            // delete\n            // store.delete(\"1\")\n            //..............................................Now Play with RecordProxy...............\n            //https://relay.dev/docs/api-reference/store/#recordproxy\n\n            /*\n               interface RecordProxy {\n               copyFieldsFrom(sourceRecord: RecordProxy): void;\n                copyFieldsFrom(sourceRecord: RecordProxy): void\n              Mutates the current record by copying the fields over from the passed in record sourceRecord.\n               Example\n              const record = store.get(id1);\n              const otherRecord = store.get(id2);\n              record.copyFieldsFrom(otherRecord); // Mutates `record`\n               \n              .............................................................................................\n               getDataID(): string;\n              \n              -> Returns the dataID of the current record.\n               .............................................................................................\n              \n              \n              getLinkedRecord(name: string, arguments?: ?Object): ?RecordProxy;\n                rootField {\n                viewer(arg: $arg) {\n                  id\n                }\n              }\n                const rootField = store.getRootField('rootField');\n              const viewer = rootField.getLinkedRecord('viewer', {arg: 'value'});\n                .............................................................................................\n               getLinkedRecords(name: string, arguments?: ?Object): ?Array<?RecordProxy>;\n               same use case but like for list , for e.g edges\n               .............................................................................................\n               getOrCreateLinkedRecord(\n                name: string,\n                typeName: string,\n                arguments?: ?Object,\n              ): RecordProxy;\n               .............................................................................................\n               getType(): string;\n               .............................................................................................\n               getValue(name: string, arguments?: ?Object): mixed;\n               .............................................................................................\n               setLinkedRecord(\n                record: RecordProxy,\n                name: string,\n                arguments?: ?Object,\n              ): RecordProxy;\n               .............................................................................................\n                setLinkedRecords(\n                records: Array<?RecordProxy>,\n                name: string,\n                arguments?: ?Object,\n              ): RecordProxy;\n               .............................................................................................\n               setValue(value: mixed, name: string, arguments?: ?Object): RecordProxy;\n                .............................................................................................\n               invalidateRecord(): void;\n               }\n             */\n            // const bookRecord = store.get(\"1\");\n            // console.log(bookRecord)\n            // console.log(\"............................getDataID()\")\n            // console.log(bookRecord?.getDataID())\n            // console.log(\"............................getType()\")\n            // console.log(bookRecord?.getType())   // what's the type of this in grpahql\n            // console.log(\"............................getValue()\")  // the value of this type' field like here title etc  (only scalar)\n            // console.log(bookRecord?.getValue(\"title\"))\n            // //console.log(bookRecord?.getValue(\"author\"))  // will give error for these use getLinkedRecord\n            // console.log(bookRecord?.getValue(\"id\"))\n            // console.log(\"............................getLinkedRecord()\")    // for author and some time some take argument so for this\n            // console.log(bookRecord?.getLinkedRecord(\"author\"))   // since return time record proxy so use these function again.\n            // other are like setting for these check doc if require simple hi hai bro\n\n            /*\n               ConnectionHandler (like in pagination system )  [don't doing now] [See doc copied from there only]\n               This interface mainly deals with manipulating pagination connections.\n               Relay runtime provides a module corresponding to it\n               ConnectionHandler is a utility module exposed by relay-runtime that aids in the \n              manipulation of connections. ConnectionHandler exposes the following interface:\n               interface ConnectionHandler {\n                 getConnection(\n                  record: RecordProxy,\n                  key: string,\n                  filters?: ?Object,\n                ): ?RecordProxy,\n                createEdge(\n                  store: RecordSourceProxy,\n                  connection: RecordProxy,\n                  node: RecordProxy,\n                  edgeType: string,\n                ): RecordProxy,\n                insertEdgeBefore(\n                  connection: RecordProxy,\n                  newEdge: RecordProxy,\n                  cursor?: ?string,\n                ): void,\n                insertEdgeAfter(\n                  connection: RecordProxy,\n                  newEdge: RecordProxy,\n                  cursor?: ?string,\n                ): void,\n                deleteNode(connection: RecordProxy, nodeID: string): void\n              }\n               .............................................................................................\n               getConnection(record: RecordProxy, key: string, filters?: ?Object)\n                Given a record and a connection key, and optionally a set of filters, \n              getConnection retrieves a RecordProxy that represents a connection that was annotated \n              with a @connection directive.\n               First, let's take a look at a plain connection:\n               fragment FriendsFragment on User {\n                friends(first: 10) {\n                  edges {\n                    node {\n                      id\n                    }\n                  }\n                }\n              }\n               Accessing a plain connection field like this is the same as other regular fields:\n               // The `friends` connection record can be accessed with:\n               const user = store.get(userID);\n              const friends = user && user.getLinkedRecord('friends');\n               // Access fields on the connection:\n               const edges = friends && friends.getLinkedRecords('edges');\n               When using usePaginationFragment, we usually annotate the actual connection \n              field with @connection to tell Relay which part needs to be paginated:\n                fragment FriendsFragment on User {\n                friends(first: 10, orderby: \"firstname\") @connection(\n                  key: \"FriendsFragment_friends\",\n                ) {\n                  edges {\n                    node {\n                      id\n                    }\n                  }\n                }\n              }\n               For connections like the above, ConnectionHandler helps us find the record:\n               import {ConnectionHandler} from 'relay-runtime';\n               // The `friends` connection record can be accessed with:\n               const user = store.get(userID);\n               const friends = ConnectionHandler.getConnection(\n              user,                        // parent record\n              'FriendsFragment_friends',   // connection key\n              {orderby: 'firstname'}       // 'filters' that is used to identify the connection\n              );\n                // Access fields on the connection:\n               const edges = friends.getLinkedRecords('edges');\n               \n              \n              .............................................................................................\n                Edge creation and insertion\n              \n              -> this can be use in automation-rule page for adding rule after saving rule without refetch.\n               createEdge(store: RecordSourceProxy, connection: RecordProxy, node: RecordProxy, edgeType: string)\n               Creates an edge given a store, a connection, the edge node, and the edge type.\n               insertEdgeBefore(connection: RecordProxy, newEdge: RecordProxy, cursor?: ?string)\n               Given a connection, inserts the edge at the beginning of the connection, \n              or before the specified cursor.\n               insertEdgeAfter(connection: RecordProxy, newEdge: RecordProxy, cursor?: ?string)\n                Given a connection, inserts the edge at the end of the connection, or after the specified cursor.\n               Example\n              const user = store.get(userID);\n              const friends = ConnectionHandler.getConnection(user, 'FriendsFragment_friends');\n              const newFriend = store.get(newFriendId);\n              const edge = ConnectionHandler.createEdge(store, friends, newFriend, 'UserEdge');\n               // No cursor provided, append the edge at the end.\n              ConnectionHandler.insertEdgeAfter(friends, edge);\n               // No cursor provided, insert the edge at the front:\n              ConnectionHandler.insertEdgeBefore(friends, edge);\n               deleteNode(connection: RecordProxy, nodeID: string): void\n              Given a connection, deletes any edges whose node id matches the given id.\n               Example\n              const user = store.get(userID);\n              const friends = ConnectionHandler.getConnection(user, 'FriendsFragment_friends');\n              ConnectionHandler.deleteNode(friends, idToDelete);\n            */\n          },\n          onError: err => console.error(err)\n        });\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"label\", {\n        htmlFor: \"fname\",\n        children: \"Book id:\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 625,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n        type: \"number\",\n        id: \"fname\",\n        placeholder: \"Type Book id\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 626,\n        columnNumber: 9\n      }, this), \" \", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 626,\n        columnNumber: 71\n      }, this), /*#__PURE__*/_jsxDEV(\"label\", {\n        htmlFor: \"fname\",\n        children: \"Book title:\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 627,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n        type: \"text\",\n        id: \"fname\",\n        placeholder: \"Type Book title\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 628,\n        columnNumber: 9\n      }, this), \" \", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 628,\n        columnNumber: 72\n      }, this), /*#__PURE__*/_jsxDEV(\"label\", {\n        htmlFor: \"fname\",\n        children: \"This author id:\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 629,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n        type: \"text\",\n        id: \"fname\",\n        placeholder: \"Type Book title\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 630,\n        columnNumber: 9\n      }, this), \" \", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 630,\n        columnNumber: 72\n      }, this), /*#__PURE__*/_jsxDEV(\"label\", {\n        htmlFor: \"fname\",\n        children: \"Author firstname:\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 631,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n        type: \"text\",\n        id: \"fname\",\n        placeholder: \"Type Book title\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 632,\n        columnNumber: 9\n      }, this), \" \", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 632,\n        columnNumber: 72\n      }, this), /*#__PURE__*/_jsxDEV(\"label\", {\n        htmlFor: \"fname\",\n        children: \"Author secondname:\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 633,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n        type: \"text\",\n        id: \"fname\",\n        placeholder: \"Type Book title\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 634,\n        columnNumber: 9\n      }, this), \" \", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 634,\n        columnNumber: 72\n      }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n        type: \"submit\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 635,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 172,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 170,\n    columnNumber: 5\n  }, this);\n}\n\n_s(Approot, \"YvL7/Tn9M7Yu9Ev+mbY39BdcYIM=\", false, function () {\n  return [useMutation, useLazyLoadQuery, useRelayEnvironment];\n});\n\n_c = Approot;\nexport default Approot;\n\nvar _c;\n\n$RefreshReg$(_c, \"Approot\");","map":{"version":3,"names":["React","App","useLazyLoadQuery","useMutation","useRelayEnvironment","appquery","appMutateupdatequery","Approot","props","commitupdate","data","fetchPolicy","storeEnv","getStore","console","log","getSource","getRecordIDs","get","idObject","books","e","preventDefault","update","id","target","value","book","title","author","firstname","secondname","variables","onCompleted","response","errors","updater","store","onError","err","error"],"sources":["/Users/anubhavgupta/Documents/react_learning/graphql-react/relay-store-learning/src/Approot.tsx"],"sourcesContent":["import React, { useCallback, useState } from \"react\";\nimport App from \"./App\";\nimport { graphql } from \"babel-plugin-relay/macro\";\nimport { useLazyLoadQuery, useMutation, useRelayEnvironment } from \"react-relay/hooks\";\nimport { RecordSourceSelectorProxy, Store } from \"relay-runtime\";\nimport {\n  ApprootQuery,\n  ApprootQuery$data,\n  ApprootQuery$variables,\n} from \"./__generated__/ApprootQuery.graphql\";\nimport {\n  ApprootupdateBookQuery,\n  ApprootupdateBookQuery$variables,\n} from \"./__generated__/ApprootupdateBookQuery.graphql\";\n\nconst appquery = graphql`\n  # Queries in graphql tags must start with the module name ('App') and end with 'Query'. Got 'allbook' instead.\n  query ApprootQuery {\n    books {\n      ...App_detail\n    }\n  }\n`;\n\nconst appMutateupdatequery = graphql`\n  # Queries in graphql tags must start with the module name ('App') and end with 'Query'. Got 'allbook' instead.\n\n  mutation ApprootupdateBookQuery($id: ID!, $book: bookInput!) {\n    updateBook(bookId: $id, book: $book) {\n      ...App_detail\n    }\n  }\n`;\n\nfunction Approot(props: any) {\n  const [commitupdate] = useMutation<ApprootupdateBookQuery>(appMutateupdatequery);\n\n  const data = useLazyLoadQuery<ApprootQuery>(appquery, {},{fetchPolicy: 'store-or-network'});\n  // console.log(\"approot......\")\n  // console.log(data);\n\n\n\n  // .........................................Let's go for learning useRelayEnvironment return type , so that can be used some where else also\n  // Aim get RecordProxy that's it\n  // some says that this is used by relay it self to managed , so not recommend to use this. always use with update etc. but hume to kar na hai\n\n\n  const storeEnv = useRelayEnvironment().getStore();\n  console.log(\".......................Not Understandable.......useRelayEnvironment().getStore(),   type: RelayModernStore\")\n  console.log(storeEnv);\n  console.log(\"......................Not Understandable........useRelayEnvironment().getStore().getSource(),   type: RelayModernStore\")\n  console.log(storeEnv.getSource());\n\n\n\n  console.log(\"...........These are the useful function for use...............\")\n  console.log(\"..............................useRelayEnvironment().getStore().getSource().getRecordIDs()\")\n\n  /*\n\n  return the list of ids which we use in store (referring to store which we get in updated)\n  store.get(\"\") \n  */\n  console.log(storeEnv.getSource().getRecordIDs());\n\n  // use to get the data for the id store.get(\"1\")\n\n  console.log(storeEnv.getSource().get(\"1\"));  // can assume this as RecordProxy\n\n  // refer: to deal with object in js \n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\n  const idObject =  storeEnv.getSource().get(\"1\");   // type object \n\n\n  console.log(idObject)\n  // console.log(Object.keys(idObject))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  /*\n\n  The useRelayEnvironment().getStore() function returns a Store object from the Relay Modern library. The type of object returned depends on the method called on the Store object.\n\n  Calling getStore().getSource() returns a RecordSource object, which is an interface for reading and writing records in the store.\n\n  Calling getStore().getSource().get(<dataID>) returns a RecordProxy object, which is a mutable interface for a single record in the store with the specified dataID.\n\n  Calling getStore().getSource().get(<selector>) returns a RecordSourceSelectorProxy object, which is a mutable interface for a set of records in the store that match the specified selector.\n\n  So, depending on which method is called on the Store object, the returned type could be either a RecordProxy or a RecordSourceSelectorProxy.\n\n\n\n\n  RelayModernStore is a central store for managing the data cache of a Relay application, \n  while RelayRecordSourceSelectorProxy is a lower-level API for reading from and writing to\n  specific pieces of data in the store.\n\n\n  The type of the store variable obtained from environment.getStore() is RelayModernStore. \n  The RelayModernStore is the central class in Relay that manages the cache of records, \n  and is responsible for reading and writing data to the cache. It is not a RecordSourceSelectorProxy \n  or RecordProxy, but it provides methods to interact with those objects.\n\n  You can use the RelayModernStore object to get a RecordSourceSelectorProxy using the getSource\n  method, which returns a RelayRecordSourceSelectorProxy. For example, to read data from the \n  cache using a RelayRecordSourceSelectorProxy, you can use the following code:\n\n\n  const store = environment.getStore();\n  const source = store.getSource();\n  const user = source.get('123');\n  console.log(user.getValue('name')); // Logs the name of the user record with ID '123'\n  \n  In this example, we get the RelayModernStore from the RelayModernEnvironment, \n  and use the getSource method to get a RelayRecordSourceSelectorProxy. We then use the get \n  method to get the user record with ID '123', and use the getValue method to read the value of\n   the name field on the user record.\n\n\n\n\n   Normalized Relay Store  --> object with id \n   Flattened Relay Store  --> with client prefix\n\n\n  how does it works ? \n\n\n\n  */\n\n\n\n    return (\n    <React.Suspense fallback={<div>Loading.....</div>}>\n      <App books={data.books[0]} />\n      <form\n        className=\"form\"\n        onSubmit={(e: any) => {\n          e.preventDefault();\n\n          let update: any = {\n            id: e.target[0].value,\n            book:{\n              id: e.target[0].value,\n              title: e.target[1].value,\n              author: {\n                id: e.target[2].value,\n                firstname: e.target[3].value,\n                secondname: e.target[4].value\n              }\n            }\n          };\n\n          commitupdate({\n            variables: update,\n            onCompleted: (response, errors) => {\n              console.log(\"Response received from server.\");\n            },\n            updater: (store) => {\n\n              console.log(\"in mutaiton\");\n\n\n              console.log(\"Type: RelayRecordSourceSelectorProxy\")\n              // Doc: https://relay.dev/docs/api-reference/store/#recordsourceselectorproxy\n\n              /*\n\n                interface RecordSourceSelectorProxy {\n\n                create(dataID: string, typeName: string): RecordProxy;\n\n                ->Creates a new record in the store given a dataID and the typeName(type Book so this book is typename) as defined by the GraphQL schema \n                \n                .............................................................................................\n                \n                delete(dataID: string): void;\n\n                -> same like create\n\n                .............................................................................................\n\n                get(dataID: string): ?RecordProxy;\n\n                .............................................................................................\n\n                getRoot(): RecordProxy;\n\n                -> Returns the RecordProxy representing the root of the GraphQL document.\n\n\n                .............................................................................................\n\n\n                getRootField(fieldName: string): ?RecordProxy;\n\n                -> Typings: \n                getRootField<K extends keyof T>(fieldName: K): RecordProxy<NonNullable<T[K]>>;\n\n                This method also allows you to fetch records from the store. How is this different \n                from the getRoot method? They differ in scope and use. While getRoot can get data \n                from the entire store, getRootField cannot. It can only get the data corresponding \n                to the concerned operation (the operation that invoked the updater function).\n\n                For example, consider the updateUser mutation:\n\n                mutation UpdateUserMutation{\n                  updateUser(id: \"ANOTHERUSER1\", newName: \"Random Name\"){\n                    id\n                    name\n                  }\n                }\n                This results in following GraphQL document:\n\n                updateUser(id: \"ANOTHERUSER1\", newName: \"Random Name\"){\n                  id\n                  name\n                }\n                getRootField can get data from this document only. But the good thing is \n                that since this was made for small documents, you can directly get the records \n                — without binding arguments to the field.\n\n                const payload = store.getRootField(\"updateUser\");\n                You can use the RecordProxy to access the payload of the mutation.\n\n                .............................................................................................\n\n                getPluralRootField(fieldName: string): ?Array<?RecordProxy>;\n\n\n                getRootField cannot get mutliple records. For such cases, we have the getPluralRootField method. So if the operation returns a collection of GraphQL objects instead of a single object, we use this method. What if the operation returned a Scalar or an array of Scalars? In that case, they won’t be stored in the store as the operation payload did not obey Global Object Identification. Moving on, Consider the generateQuestions mutation:\n\n                mutation GenerateQuestionsMutation{\n                # generate n random questions\n                # generateQuestions(n: Int!): [Question!]!\n                  generateQuestions(n: 10){\n                    id\n                    description\n                  }\n                }\n                This results in following GraphQL document:\n\n                generateQuestions(n: 10){\n                  # Returns 10 randomly generated questions\n                  id\n                  description\n                }\n                If I try to use store.getRootField(\"generateUsers\") , \n                it won’t work as generateQuestions returns an array of Users . \n                Instead, I need to do\n\n                const payload = store.getRootPluralField(\"generateQuestions\");\n                The payload will contain the array of Questions (RecordProxy of type Question) .\n                \n                You can then access it like a normal array\n\n                const descriptions = payload.map(question => question.getValue(\"description\"));\n\n                .............................................................................................\n\n                invalidateStore(): void;\n\n\n                Globally invalidates the Relay store. This will cause any data that was written to the\n                store before invalidation occurred to be considered stale, and will be considered to\n                require refetch the next time a query is checked with environment.check().\n\n                Example\n                store.invalidateStore();\n\n                After global invalidation, any query that is checked before refetching it will be \n                considered stale:\n\n                environment.check(query) === 'stale'\n \n              */\n\n              // create\n\n              // const manualdata = store.create(\"anubhav|122\", \"manual\")\n\n\n\n\n\n              // console.log(store);\n              // console.log(\"............................store.get(1)\")\n              // console.log(store.get(\"1\"));\n              // console.log(\"............................store.get(client:root)\")\n              // console.log(store.get(\"client:root\"));\n              // console.log(\"............................store.get(3)\")\n              // console.log(store.get(\"3\"));\n              // console.log(\"............................store.get(wrong)\")\n              // console.log(store.get(\"wrong\")); // will get undefined\n              // console.log(\"............................store.getRoot()\")\n              // console.log(store.getRoot());\n              \n              \n\n              // //getRootField\n              // console.log(\"............................store.getRootField()\")    \n              // console.log(store.getRootField('updateBook'));\n\n\n\n              \n\n              // (window as any).store = store;\n\n              // delete\n              // store.delete(\"1\")\n\n              //..............................................Now Play with RecordProxy...............\n\n              //https://relay.dev/docs/api-reference/store/#recordproxy\n\n\n              /*\n\n                interface RecordProxy {\n\n                copyFieldsFrom(sourceRecord: RecordProxy): void;\n\n\n                copyFieldsFrom(sourceRecord: RecordProxy): void\n                Mutates the current record by copying the fields over from the passed in record sourceRecord.\n\n                Example\n                const record = store.get(id1);\n                const otherRecord = store.get(id2);\n                record.copyFieldsFrom(otherRecord); // Mutates `record`\n\n                \n                .............................................................................................\n\n                getDataID(): string;\n                \n                -> Returns the dataID of the current record.\n\n                .............................................................................................\n                \n                \n                getLinkedRecord(name: string, arguments?: ?Object): ?RecordProxy;\n\n\n                rootField {\n                  viewer(arg: $arg) {\n                    id\n                  }\n                }\n\n\n                const rootField = store.getRootField('rootField');\n                const viewer = rootField.getLinkedRecord('viewer', {arg: 'value'});\n\n\n                .............................................................................................\n\n                getLinkedRecords(name: string, arguments?: ?Object): ?Array<?RecordProxy>;\n\n                same use case but like for list , for e.g edges\n\n                .............................................................................................\n\n                getOrCreateLinkedRecord(\n                  name: string,\n                  typeName: string,\n                  arguments?: ?Object,\n                ): RecordProxy;\n\n                .............................................................................................\n\n                getType(): string;\n\n                .............................................................................................\n\n                getValue(name: string, arguments?: ?Object): mixed;\n\n                .............................................................................................\n\n                setLinkedRecord(\n                  record: RecordProxy,\n                  name: string,\n                  arguments?: ?Object,\n                ): RecordProxy;\n\n                .............................................................................................\n\n\n                setLinkedRecords(\n                  records: Array<?RecordProxy>,\n                  name: string,\n                  arguments?: ?Object,\n                ): RecordProxy;\n\n                .............................................................................................\n\n                setValue(value: mixed, name: string, arguments?: ?Object): RecordProxy;\n\n\n                .............................................................................................\n\n                invalidateRecord(): void;\n\n                }\n\n              */\n\n\n              // const bookRecord = store.get(\"1\");\n              // console.log(bookRecord)\n\n              // console.log(\"............................getDataID()\")\n              // console.log(bookRecord?.getDataID())\n\n              // console.log(\"............................getType()\")\n              // console.log(bookRecord?.getType())   // what's the type of this in grpahql\n\n\n              // console.log(\"............................getValue()\")  // the value of this type' field like here title etc  (only scalar)\n              // console.log(bookRecord?.getValue(\"title\"))\n              // //console.log(bookRecord?.getValue(\"author\"))  // will give error for these use getLinkedRecord\n              // console.log(bookRecord?.getValue(\"id\"))\n\n\n              // console.log(\"............................getLinkedRecord()\")    // for author and some time some take argument so for this\n              // console.log(bookRecord?.getLinkedRecord(\"author\"))   // since return time record proxy so use these function again.\n\n\n\n              // other are like setting for these check doc if require simple hi hai bro\n\n\n\n\n              /*\n\n                ConnectionHandler (like in pagination system )  [don't doing now] [See doc copied from there only]\n\n                This interface mainly deals with manipulating pagination connections.\n                 Relay runtime provides a module corresponding to it\n\n                ConnectionHandler is a utility module exposed by relay-runtime that aids in the \n                manipulation of connections. ConnectionHandler exposes the following interface:\n\n                interface ConnectionHandler {\n\n                  getConnection(\n                    record: RecordProxy,\n                    key: string,\n                    filters?: ?Object,\n                  ): ?RecordProxy,\n                  createEdge(\n                    store: RecordSourceProxy,\n                    connection: RecordProxy,\n                    node: RecordProxy,\n                    edgeType: string,\n                  ): RecordProxy,\n                  insertEdgeBefore(\n                    connection: RecordProxy,\n                    newEdge: RecordProxy,\n                    cursor?: ?string,\n                  ): void,\n                  insertEdgeAfter(\n                    connection: RecordProxy,\n                    newEdge: RecordProxy,\n                    cursor?: ?string,\n                  ): void,\n                  deleteNode(connection: RecordProxy, nodeID: string): void\n                }\n\n                .............................................................................................\n\n                getConnection(record: RecordProxy, key: string, filters?: ?Object)\n\n\n                Given a record and a connection key, and optionally a set of filters, \n                getConnection retrieves a RecordProxy that represents a connection that was annotated \n                with a @connection directive.\n\n                First, let's take a look at a plain connection:\n\n                fragment FriendsFragment on User {\n                  friends(first: 10) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n\n                Accessing a plain connection field like this is the same as other regular fields:\n\n                // The `friends` connection record can be accessed with:\n\n                const user = store.get(userID);\n                const friends = user && user.getLinkedRecord('friends');\n\n                // Access fields on the connection:\n\n                const edges = friends && friends.getLinkedRecords('edges');\n\n                When using usePaginationFragment, we usually annotate the actual connection \n                field with @connection to tell Relay which part needs to be paginated:\n\n\n                fragment FriendsFragment on User {\n                  friends(first: 10, orderby: \"firstname\") @connection(\n                    key: \"FriendsFragment_friends\",\n                  ) {\n                    edges {\n                      node {\n                        id\n                      }\n                    }\n                  }\n                }\n\n                For connections like the above, ConnectionHandler helps us find the record:\n\n                import {ConnectionHandler} from 'relay-runtime';\n\n                // The `friends` connection record can be accessed with:\n\n                const user = store.get(userID);\n\n                const friends = ConnectionHandler.getConnection(\n                user,                        // parent record\n                'FriendsFragment_friends',   // connection key\n                {orderby: 'firstname'}       // 'filters' that is used to identify the connection\n                );\n\n\n                // Access fields on the connection:\n\n                const edges = friends.getLinkedRecords('edges');\n\n                \n                \n                .............................................................................................\n\n\n                Edge creation and insertion\n                \n                -> this can be use in automation-rule page for adding rule after saving rule without refetch.\n\n                createEdge(store: RecordSourceProxy, connection: RecordProxy, node: RecordProxy, edgeType: string)\n\n                Creates an edge given a store, a connection, the edge node, and the edge type.\n\n                insertEdgeBefore(connection: RecordProxy, newEdge: RecordProxy, cursor?: ?string)\n\n                Given a connection, inserts the edge at the beginning of the connection, \n                or before the specified cursor.\n\n                insertEdgeAfter(connection: RecordProxy, newEdge: RecordProxy, cursor?: ?string)\n\n\n                Given a connection, inserts the edge at the end of the connection, or after the specified cursor.\n\n                Example\n                const user = store.get(userID);\n                const friends = ConnectionHandler.getConnection(user, 'FriendsFragment_friends');\n                const newFriend = store.get(newFriendId);\n                const edge = ConnectionHandler.createEdge(store, friends, newFriend, 'UserEdge');\n\n                // No cursor provided, append the edge at the end.\n                ConnectionHandler.insertEdgeAfter(friends, edge);\n\n                // No cursor provided, insert the edge at the front:\n                ConnectionHandler.insertEdgeBefore(friends, edge);\n\n                deleteNode(connection: RecordProxy, nodeID: string): void\n                Given a connection, deletes any edges whose node id matches the given id.\n\n                Example\n                const user = store.get(userID);\n                const friends = ConnectionHandler.getConnection(user, 'FriendsFragment_friends');\n                ConnectionHandler.deleteNode(friends, idToDelete);\n              */\n\n                \n            },\n            onError: (err) => console.error(err),\n          });\n        }}\n      >\n        <label htmlFor=\"fname\">Book id:</label>\n        <input type=\"number\" id=\"fname\" placeholder=\"Type Book id\" /> <br></br>\n        <label htmlFor=\"fname\">Book title:</label>\n        <input type=\"text\" id=\"fname\" placeholder=\"Type Book title\" /> <br></br>\n        <label htmlFor=\"fname\">This author id:</label>\n        <input type=\"text\" id=\"fname\" placeholder=\"Type Book title\" /> <br></br>\n        <label htmlFor=\"fname\">Author firstname:</label>\n        <input type=\"text\" id=\"fname\" placeholder=\"Type Book title\" /> <br></br>\n        <label htmlFor=\"fname\">Author secondname:</label>\n        <input type=\"text\" id=\"fname\" placeholder=\"Type Book title\" /> <br></br>\n        <input type=\"submit\" />\n      </form>\n    </React.Suspense>\n  );\n}\n\nexport default Approot;\n"],"mappings":"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;YAqCc;YAEA;YAMA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YAIA;YACA;YACA;YAMA;YAEA;YACA;YAEA;YAEA;;YAGA;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;YAqCc;YACA;YAEA;YACA;YAEA;YACA;YAGA;YACA;YACA;YACA;YAGA;YACA;YAIA;;YAKA;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;UA6Ca,CA9aU;UA+aXuB,OAAO,EAAGC,GAAD,IAASzB,OAAO,CAAC0B,KAAR,CAAcD,GAAd;QA/aP,CAAD,CAAZ;MAibD,CAncH;MAAA,wBAqcE;QAAO,OAAO,EAAC,OAAf;QAAA;MAAA;QAAA;QAAA;QAAA;MAAA,QArcF,eAscE;QAAO,IAAI,EAAC,QAAZ;QAAqB,EAAE,EAAC,OAAxB;QAAgC,WAAW,EAAC;MAA5C;QAAA;QAAA;QAAA;MAAA,QAtcF,oBAscgE;QAAA;QAAA;QAAA;MAAA,QAtchE,eAucE;QAAO,OAAO,EAAC,OAAf;QAAA;MAAA;QAAA;QAAA;QAAA;MAAA,QAvcF,eAwcE;QAAO,IAAI,EAAC,MAAZ;QAAmB,EAAE,EAAC,OAAtB;QAA8B,WAAW,EAAC;MAA1C;QAAA;QAAA;QAAA;MAAA,QAxcF,oBAwciE;QAAA;QAAA;QAAA;MAAA,QAxcjE,eAycE;QAAO,OAAO,EAAC,OAAf;QAAA;MAAA;QAAA;QAAA;QAAA;MAAA,QAzcF,eA0cE;QAAO,IAAI,EAAC,MAAZ;QAAmB,EAAE,EAAC,OAAtB;QAA8B,WAAW,EAAC;MAA1C;QAAA;QAAA;QAAA;MAAA,QA1cF,oBA0ciE;QAAA;QAAA;QAAA;MAAA,QA1cjE,eA2cE;QAAO,OAAO,EAAC,OAAf;QAAA;MAAA;QAAA;QAAA;QAAA;MAAA,QA3cF,eA4cE;QAAO,IAAI,EAAC,MAAZ;QAAmB,EAAE,EAAC,OAAtB;QAA8B,WAAW,EAAC;MAA1C;QAAA;QAAA;QAAA;MAAA,QA5cF,oBA4ciE;QAAA;QAAA;QAAA;MAAA,QA5cjE,eA6cE;QAAO,OAAO,EAAC,OAAf;QAAA;MAAA;QAAA;QAAA;QAAA;MAAA,QA7cF,eA8cE;QAAO,IAAI,EAAC,MAAZ;QAAmB,EAAE,EAAC,OAAtB;QAA8B,WAAW,EAAC;MAA1C;QAAA;QAAA;QAAA;MAAA,QA9cF,oBA8ciE;QAAA;QAAA;QAAA;MAAA,QA9cjE,eA+cE;QAAO,IAAI,EAAC;MAAZ;QAAA;QAAA;QAAA;MAAA,QA/cF;IAAA;MAAA;MAAA;MAAA;IAAA,QAFF;EAAA;IAAA;IAAA;IAAA;EAAA,QADA;AAsdH;;GA5lBQhC,O;UACgBJ,W,EAEVD,gB,EAWIE,mB;;;KAdVG,O;AA8lBT,eAAeA,OAAf"},"metadata":{},"sourceType":"module"}