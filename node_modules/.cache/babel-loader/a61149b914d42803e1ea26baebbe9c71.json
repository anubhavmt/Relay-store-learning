{"ast":null,"code":"import inspect from \"../jsutils/inspect.mjs\";\nimport devAssert from \"../jsutils/devAssert.mjs\";\nimport { syntaxError } from \"../error/syntaxError.mjs\";\nimport { Kind } from \"./kinds.mjs\";\nimport { Location } from \"./ast.mjs\";\nimport { Source } from \"./source.mjs\";\nimport { TokenKind } from \"./tokenKind.mjs\";\nimport { DirectiveLocation } from \"./directiveLocation.mjs\";\nimport { Lexer, isPunctuatorTokenKind } from \"./lexer.mjs\";\n/**\n * Configuration options to control parser behavior\n */\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\n\nexport function parse(source, options) {\n  var parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\nexport function parseValue(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\nexport function parseType(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\n\nvar Parser = /*#__PURE__*/function () {\n  function Parser(source, options) {\n    var sourceObj = typeof source === 'string' ? new Source(source) : source;\n    sourceObj instanceof Source || devAssert(0, \"Must provide Source. Received: \".concat(inspect(sourceObj), \".\"));\n    this._lexer = new Lexer(sourceObj);\n    this._options = options;\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n\n  var _proto = Parser.prototype;\n\n  _proto.parseName = function parseName() {\n    var token = this.expectToken(TokenKind.NAME);\n    return {\n      kind: Kind.NAME,\n      value: token.value,\n      loc: this.loc(token)\n    };\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n  ;\n\n  _proto.parseDocument = function parseDocument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   */\n  ;\n\n  _proto.parseDefinition = function parseDefinition() {\n    if (this.peek(TokenKind.NAME)) {\n      switch (this._lexer.token.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'schema':\n        case 'scalar':\n        case 'type':\n        case 'interface':\n        case 'union':\n        case 'enum':\n        case 'input':\n        case 'directive':\n          return this.parseTypeSystemDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    } else if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } else if (this.peekDescription()) {\n      return this.parseTypeSystemDefinition();\n    }\n\n    throw this.unexpected();\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n  ;\n\n  _proto.parseOperationDefinition = function parseOperationDefinition() {\n    var start = this._lexer.token;\n\n    if (this.peek(TokenKind.BRACE_L)) {\n      return {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: 'query',\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    var operation = this.parseOperationType();\n    var name;\n\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return {\n      kind: Kind.OPERATION_DEFINITION,\n      operation: operation,\n      name: name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n  ;\n\n  _proto.parseOperationType = function parseOperationType() {\n    var operationToken = this.expectToken(TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return 'query';\n\n      case 'mutation':\n        return 'mutation';\n\n      case 'subscription':\n        return 'subscription';\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n  ;\n\n  _proto.parseVariableDefinitions = function parseVariableDefinitions() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n  ;\n\n  _proto.parseVariableDefinition = function parseVariableDefinition() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseValueLiteral(true) : undefined,\n      directives: this.parseDirectives(true),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Variable : $ Name\n   */\n  ;\n\n  _proto.parseVariable = function parseVariable() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return {\n      kind: Kind.VARIABLE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * SelectionSet : { Selection+ }\n   */\n  ;\n\n  _proto.parseSelectionSet = function parseSelectionSet() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n  ;\n\n  _proto.parseSelection = function parseSelection() {\n    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n  ;\n\n  _proto.parseField = function parseField() {\n    var start = this._lexer.token;\n    var nameOrAlias = this.parseName();\n    var alias;\n    var name;\n\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return {\n      kind: Kind.FIELD,\n      alias: alias,\n      name: name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n  ;\n\n  _proto.parseArguments = function parseArguments(isConst) {\n    var item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n  ;\n\n  _proto.parseArgument = function parseArgument() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.ARGUMENT,\n      name: name,\n      value: this.parseValueLiteral(false),\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseConstArgument = function parseConstArgument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.ARGUMENT,\n      name: this.parseName(),\n      value: (this.expectToken(TokenKind.COLON), this.parseValueLiteral(true)),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n  ;\n\n  _proto.parseFragment = function parseFragment() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    var hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n  ;\n\n  _proto.parseFragmentDefinition = function parseFragmentDefinition() {\n    var _this$_options;\n\n    var start = this._lexer.token;\n    this.expectKeyword('fragment'); // Experimental support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.experimentalFragmentVariables) === true) {\n      return {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n  ;\n\n  _proto.parseFragmentName = function parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n  ;\n\n  _proto.parseValueLiteral = function parseValueLiteral(isConst) {\n    var token = this._lexer.token;\n\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case TokenKind.INT:\n        this._lexer.advance();\n\n        return {\n          kind: Kind.INT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.FLOAT:\n        this._lexer.advance();\n\n        return {\n          kind: Kind.FLOAT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case TokenKind.NAME:\n        this._lexer.advance();\n\n        switch (token.value) {\n          case 'true':\n            return {\n              kind: Kind.BOOLEAN,\n              value: true,\n              loc: this.loc(token)\n            };\n\n          case 'false':\n            return {\n              kind: Kind.BOOLEAN,\n              value: false,\n              loc: this.loc(token)\n            };\n\n          case 'null':\n            return {\n              kind: Kind.NULL,\n              loc: this.loc(token)\n            };\n\n          default:\n            return {\n              kind: Kind.ENUM,\n              value: token.value,\n              loc: this.loc(token)\n            };\n        }\n\n      case TokenKind.DOLLAR:\n        if (!isConst) {\n          return this.parseVariable();\n        }\n\n        break;\n    }\n\n    throw this.unexpected();\n  };\n\n  _proto.parseStringLiteral = function parseStringLiteral() {\n    var token = this._lexer.token;\n\n    this._lexer.advance();\n\n    return {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING,\n      loc: this.loc(token)\n    };\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n  ;\n\n  _proto.parseList = function parseList(isConst) {\n    var _this = this;\n\n    var start = this._lexer.token;\n\n    var item = function item() {\n      return _this.parseValueLiteral(isConst);\n    };\n\n    return {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   */\n  ;\n\n  _proto.parseObject = function parseObject(isConst) {\n    var _this2 = this;\n\n    var start = this._lexer.token;\n\n    var item = function item() {\n      return _this2.parseObjectField(isConst);\n    };\n\n    return {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n  ;\n\n  _proto.parseObjectField = function parseObjectField(isConst) {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.OBJECT_FIELD,\n      name: name,\n      value: this.parseValueLiteral(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n  ;\n\n  _proto.parseDirectives = function parseDirectives(isConst) {\n    var directives = [];\n\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n  /**\n   * Directive[Const] : @ Name Arguments[?Const]?\n   */\n  ;\n\n  _proto.parseDirective = function parseDirective(isConst) {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n  ;\n\n  _proto.parseTypeReference = function parseTypeReference() {\n    var start = this._lexer.token;\n    var type;\n\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      type = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = {\n        kind: Kind.LIST_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return {\n        kind: Kind.NON_NULL_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n  ;\n\n  _proto.parseNamedType = function parseNamedType() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Type Definition section.\n\n  /**\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n  ;\n\n  _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {\n    // Many definitions begin with a description and require a lookahead.\n    var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  };\n\n  _proto.peekDescription = function peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  /**\n   * Description : StringValue\n   */\n  ;\n\n  _proto.parseDescription = function parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n   */\n  ;\n\n  _proto.parseSchemaDefinition = function parseSchemaDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n    return {\n      kind: Kind.SCHEMA_DEFINITION,\n      description: description,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n  ;\n\n  _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {\n    var start = this._lexer.token;\n    var operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseNamedType();\n    return {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation: operation,\n      type: type,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n  ;\n\n  _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n  ;\n\n  _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n  ;\n\n  _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {\n    var types = [];\n\n    if (this.expectOptionalKeyword('implements')) {\n      // Optional leading ampersand\n      this.expectOptionalToken(TokenKind.AMP);\n\n      do {\n        var _this$_options2;\n\n        types.push(this.parseNamedType());\n      } while (this.expectOptionalToken(TokenKind.AMP) || // Legacy support for the SDL?\n      ((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.allowLegacySDLImplementsInterfaces) === true && this.peek(TokenKind.NAME));\n    }\n\n    return types;\n  }\n  /**\n   * FieldsDefinition : { FieldDefinition+ }\n   */\n  ;\n\n  _proto.parseFieldsDefinition = function parseFieldsDefinition() {\n    var _this$_options3; // Legacy support for the SDL?\n\n\n    if (((_this$_options3 = this._options) === null || _this$_options3 === void 0 ? void 0 : _this$_options3.allowLegacySDLEmptyFields) === true && this.peek(TokenKind.BRACE_L) && this._lexer.lookahead().kind === TokenKind.BRACE_R) {\n      this._lexer.advance();\n\n      this._lexer.advance();\n\n      return [];\n    }\n\n    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n  ;\n\n  _proto.parseFieldDefinition = function parseFieldDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.FIELD_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      type: type,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n  ;\n\n  _proto.parseArgumentDefs = function parseArgumentDefs() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n  ;\n\n  _proto.parseInputValueDef = function parseInputValueDef() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var defaultValue;\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseValueLiteral(true);\n    }\n\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      type: type,\n      defaultValue: defaultValue,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n  ;\n\n  _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n  ;\n\n  _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n    return {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n  ;\n\n  _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {\n    var types = [];\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      // Optional leading pipe\n      this.expectOptionalToken(TokenKind.PIPE);\n\n      do {\n        types.push(this.parseNamedType());\n      } while (this.expectOptionalToken(TokenKind.PIPE));\n    }\n\n    return types;\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n  ;\n\n  _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n    return {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   */\n  ;\n\n  _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   *\n   * EnumValue : Name\n   */\n  ;\n\n  _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n  ;\n\n  _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   */\n  ;\n\n  _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n  ;\n\n  _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {\n    var keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   */\n  ;\n\n  _proto.parseSchemaExtension = function parseSchemaExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n  ;\n\n  _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n  ;\n\n  _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InterfaceTypeExtension :\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\n   *  - extend interface Name ImplementsInterfaces\n   */\n  ;\n\n  _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n  ;\n\n  _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n  ;\n\n  _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n  ;\n\n  _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   */\n  ;\n\n  _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    var repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    var locations = this.parseDirectiveLocations();\n    return {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      repeatable: repeatable,\n      locations: locations,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n  ;\n\n  _proto.parseDirectiveLocations = function parseDirectiveLocations() {\n    // Optional leading pipe\n    this.expectOptionalToken(TokenKind.PIPE);\n    var locations = [];\n\n    do {\n      locations.push(this.parseDirectiveLocation());\n    } while (this.expectOptionalToken(TokenKind.PIPE));\n\n    return locations;\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n  ;\n\n  _proto.parseDirectiveLocation = function parseDirectiveLocation() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n\n    if (DirectiveLocation[name.value] !== undefined) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a location object, used to identify the place in\n   * the source that created a given parsed object.\n   */\n  ;\n\n  _proto.loc = function loc(startToken) {\n    var _this$_options4;\n\n    if (((_this$_options4 = this._options) === null || _this$_options4 === void 0 ? void 0 : _this$_options4.noLocation) !== true) {\n      return new Location(startToken, this._lexer.lastToken, this._lexer.source);\n    }\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n  ;\n\n  _proto.peek = function peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing\n   * the lexer. Otherwise, do not change the parser state and throw an error.\n   */\n  ;\n\n  _proto.expectToken = function expectToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    throw syntaxError(this._lexer.source, token.start, \"Expected \".concat(getTokenKindDesc(kind), \", found \").concat(getTokenDesc(token), \".\"));\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing\n   * the lexer. Otherwise, do not change the parser state and return undefined.\n   */\n  ;\n\n  _proto.expectOptionalToken = function expectOptionalToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    return undefined;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n  ;\n\n  _proto.expectKeyword = function expectKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n    } else {\n      throw syntaxError(this._lexer.source, token.start, \"Expected \\\"\".concat(value, \"\\\", found \").concat(getTokenDesc(token), \".\"));\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing\n   * the lexer. Otherwise, do not change the parser state and return \"false\".\n   */\n  ;\n\n  _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token\n   * is encountered.\n   */\n  ;\n\n  _proto.unexpected = function unexpected(atToken) {\n    var token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return syntaxError(this._lexer.source, token.start, \"Unexpected \".concat(getTokenDesc(token), \".\"));\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by\n   * the parseFn. This list begins with a lex token of openKind\n   * and ends with a lex token of closeKind. Advances the parser\n   * to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.any = function any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always\n   * return non-empty list that begins with a lex token of openKind and ends\n   * with a lex token of closeKind. Advances the parser to the next lex token\n   * after the closing token.\n   */\n  ;\n\n  _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      var nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by\n   * the parseFn. This list begins with a lex token of openKind\n   * and ends with a lex token of closeKind. Advances the parser\n   * to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.many = function many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  };\n\n  return Parser;\n}();\n/**\n * A helper function to describe a token as a string for debugging\n */\n\n\nfunction getTokenDesc(token) {\n  var value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? \" \\\"\".concat(value, \"\\\"\") : '');\n}\n/**\n * A helper function to describe a token kind as a string for debugging\n */\n\n\nfunction getTokenKindDesc(kind) {\n  return isPunctuatorTokenKind(kind) ? \"\\\"\".concat(kind, \"\\\"\") : kind;\n}","map":{"version":3,"names":["inspect","devAssert","syntaxError","Kind","Location","Source","TokenKind","DirectiveLocation","Lexer","isPunctuatorTokenKind","parse","source","options","parser","Parser","parseDocument","parseValue","expectToken","SOF","value","parseValueLiteral","EOF","parseType","type","parseTypeReference","sourceObj","concat","_lexer","_options","_proto","prototype","parseName","token","NAME","kind","loc","start","DOCUMENT","definitions","many","parseDefinition","peek","parseOperationDefinition","parseFragmentDefinition","parseTypeSystemDefinition","parseTypeSystemExtension","BRACE_L","peekDescription","unexpected","OPERATION_DEFINITION","operation","name","undefined","variableDefinitions","directives","selectionSet","parseSelectionSet","parseOperationType","parseVariableDefinitions","parseDirectives","operationToken","optionalMany","PAREN_L","parseVariableDefinition","PAREN_R","VARIABLE_DEFINITION","variable","parseVariable","COLON","defaultValue","expectOptionalToken","EQUALS","DOLLAR","VARIABLE","SELECTION_SET","selections","parseSelection","BRACE_R","SPREAD","parseFragment","parseField","nameOrAlias","alias","FIELD","arguments","parseArguments","isConst","item","parseConstArgument","parseArgument","ARGUMENT","hasTypeCondition","expectOptionalKeyword","FRAGMENT_SPREAD","parseFragmentName","INLINE_FRAGMENT","typeCondition","parseNamedType","_this$_options","expectKeyword","experimentalFragmentVariables","FRAGMENT_DEFINITION","BRACKET_L","parseList","parseObject","INT","advance","FLOAT","STRING","BLOCK_STRING","parseStringLiteral","BOOLEAN","NULL","ENUM","block","_this","LIST","values","any","BRACKET_R","_this2","parseObjectField","OBJECT","fields","OBJECT_FIELD","AT","push","parseDirective","DIRECTIVE","LIST_TYPE","BANG","NON_NULL_TYPE","NAMED_TYPE","keywordToken","lookahead","parseSchemaDefinition","parseScalarTypeDefinition","parseObjectTypeDefinition","parseInterfaceTypeDefinition","parseUnionTypeDefinition","parseEnumTypeDefinition","parseInputObjectTypeDefinition","parseDirectiveDefinition","parseDescription","description","operationTypes","parseOperationTypeDefinition","SCHEMA_DEFINITION","OPERATION_TYPE_DEFINITION","SCALAR_TYPE_DEFINITION","interfaces","parseImplementsInterfaces","parseFieldsDefinition","OBJECT_TYPE_DEFINITION","types","AMP","_this$_options2","allowLegacySDLImplementsInterfaces","_this$_options3","allowLegacySDLEmptyFields","parseFieldDefinition","args","parseArgumentDefs","FIELD_DEFINITION","parseInputValueDef","INPUT_VALUE_DEFINITION","INTERFACE_TYPE_DEFINITION","parseUnionMemberTypes","UNION_TYPE_DEFINITION","PIPE","parseEnumValuesDefinition","ENUM_TYPE_DEFINITION","parseEnumValueDefinition","ENUM_VALUE_DEFINITION","parseInputFieldsDefinition","INPUT_OBJECT_TYPE_DEFINITION","parseSchemaExtension","parseScalarTypeExtension","parseObjectTypeExtension","parseInterfaceTypeExtension","parseUnionTypeExtension","parseEnumTypeExtension","parseInputObjectTypeExtension","length","SCHEMA_EXTENSION","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","repeatable","locations","parseDirectiveLocations","DIRECTIVE_DEFINITION","parseDirectiveLocation","startToken","_this$_options4","noLocation","lastToken","getTokenKindDesc","getTokenDesc","atToken","openKind","parseFn","closeKind","nodes","call"],"sources":["/Users/anubhavgupta/Documents/react_learning/graphql-react/relay-learning/node_modules/graphql/language/parser.mjs"],"sourcesContent":["import inspect from \"../jsutils/inspect.mjs\";\nimport devAssert from \"../jsutils/devAssert.mjs\";\nimport { syntaxError } from \"../error/syntaxError.mjs\";\nimport { Kind } from \"./kinds.mjs\";\nimport { Location } from \"./ast.mjs\";\nimport { Source } from \"./source.mjs\";\nimport { TokenKind } from \"./tokenKind.mjs\";\nimport { DirectiveLocation } from \"./directiveLocation.mjs\";\nimport { Lexer, isPunctuatorTokenKind } from \"./lexer.mjs\";\n/**\n * Configuration options to control parser behavior\n */\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nexport function parse(source, options) {\n  var parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\nexport function parseValue(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\nexport function parseType(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\n\nvar Parser = /*#__PURE__*/function () {\n  function Parser(source, options) {\n    var sourceObj = typeof source === 'string' ? new Source(source) : source;\n    sourceObj instanceof Source || devAssert(0, \"Must provide Source. Received: \".concat(inspect(sourceObj), \".\"));\n    this._lexer = new Lexer(sourceObj);\n    this._options = options;\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n\n  var _proto = Parser.prototype;\n\n  _proto.parseName = function parseName() {\n    var token = this.expectToken(TokenKind.NAME);\n    return {\n      kind: Kind.NAME,\n      value: token.value,\n      loc: this.loc(token)\n    };\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n  ;\n\n  _proto.parseDocument = function parseDocument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   */\n  ;\n\n  _proto.parseDefinition = function parseDefinition() {\n    if (this.peek(TokenKind.NAME)) {\n      switch (this._lexer.token.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'schema':\n        case 'scalar':\n        case 'type':\n        case 'interface':\n        case 'union':\n        case 'enum':\n        case 'input':\n        case 'directive':\n          return this.parseTypeSystemDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    } else if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } else if (this.peekDescription()) {\n      return this.parseTypeSystemDefinition();\n    }\n\n    throw this.unexpected();\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n  ;\n\n  _proto.parseOperationDefinition = function parseOperationDefinition() {\n    var start = this._lexer.token;\n\n    if (this.peek(TokenKind.BRACE_L)) {\n      return {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: 'query',\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    var operation = this.parseOperationType();\n    var name;\n\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return {\n      kind: Kind.OPERATION_DEFINITION,\n      operation: operation,\n      name: name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n  ;\n\n  _proto.parseOperationType = function parseOperationType() {\n    var operationToken = this.expectToken(TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return 'query';\n\n      case 'mutation':\n        return 'mutation';\n\n      case 'subscription':\n        return 'subscription';\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n  ;\n\n  _proto.parseVariableDefinitions = function parseVariableDefinitions() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n  ;\n\n  _proto.parseVariableDefinition = function parseVariableDefinition() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseValueLiteral(true) : undefined,\n      directives: this.parseDirectives(true),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Variable : $ Name\n   */\n  ;\n\n  _proto.parseVariable = function parseVariable() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return {\n      kind: Kind.VARIABLE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * SelectionSet : { Selection+ }\n   */\n  ;\n\n  _proto.parseSelectionSet = function parseSelectionSet() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n  ;\n\n  _proto.parseSelection = function parseSelection() {\n    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n  ;\n\n  _proto.parseField = function parseField() {\n    var start = this._lexer.token;\n    var nameOrAlias = this.parseName();\n    var alias;\n    var name;\n\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return {\n      kind: Kind.FIELD,\n      alias: alias,\n      name: name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n  ;\n\n  _proto.parseArguments = function parseArguments(isConst) {\n    var item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n  ;\n\n  _proto.parseArgument = function parseArgument() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.ARGUMENT,\n      name: name,\n      value: this.parseValueLiteral(false),\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseConstArgument = function parseConstArgument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.ARGUMENT,\n      name: this.parseName(),\n      value: (this.expectToken(TokenKind.COLON), this.parseValueLiteral(true)),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n  ;\n\n  _proto.parseFragment = function parseFragment() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    var hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n  ;\n\n  _proto.parseFragmentDefinition = function parseFragmentDefinition() {\n    var _this$_options;\n\n    var start = this._lexer.token;\n    this.expectKeyword('fragment'); // Experimental support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.experimentalFragmentVariables) === true) {\n      return {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n  ;\n\n  _proto.parseFragmentName = function parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n  ;\n\n  _proto.parseValueLiteral = function parseValueLiteral(isConst) {\n    var token = this._lexer.token;\n\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case TokenKind.INT:\n        this._lexer.advance();\n\n        return {\n          kind: Kind.INT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.FLOAT:\n        this._lexer.advance();\n\n        return {\n          kind: Kind.FLOAT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case TokenKind.NAME:\n        this._lexer.advance();\n\n        switch (token.value) {\n          case 'true':\n            return {\n              kind: Kind.BOOLEAN,\n              value: true,\n              loc: this.loc(token)\n            };\n\n          case 'false':\n            return {\n              kind: Kind.BOOLEAN,\n              value: false,\n              loc: this.loc(token)\n            };\n\n          case 'null':\n            return {\n              kind: Kind.NULL,\n              loc: this.loc(token)\n            };\n\n          default:\n            return {\n              kind: Kind.ENUM,\n              value: token.value,\n              loc: this.loc(token)\n            };\n        }\n\n      case TokenKind.DOLLAR:\n        if (!isConst) {\n          return this.parseVariable();\n        }\n\n        break;\n    }\n\n    throw this.unexpected();\n  };\n\n  _proto.parseStringLiteral = function parseStringLiteral() {\n    var token = this._lexer.token;\n\n    this._lexer.advance();\n\n    return {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING,\n      loc: this.loc(token)\n    };\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n  ;\n\n  _proto.parseList = function parseList(isConst) {\n    var _this = this;\n\n    var start = this._lexer.token;\n\n    var item = function item() {\n      return _this.parseValueLiteral(isConst);\n    };\n\n    return {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   */\n  ;\n\n  _proto.parseObject = function parseObject(isConst) {\n    var _this2 = this;\n\n    var start = this._lexer.token;\n\n    var item = function item() {\n      return _this2.parseObjectField(isConst);\n    };\n\n    return {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n  ;\n\n  _proto.parseObjectField = function parseObjectField(isConst) {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.OBJECT_FIELD,\n      name: name,\n      value: this.parseValueLiteral(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n  ;\n\n  _proto.parseDirectives = function parseDirectives(isConst) {\n    var directives = [];\n\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n  /**\n   * Directive[Const] : @ Name Arguments[?Const]?\n   */\n  ;\n\n  _proto.parseDirective = function parseDirective(isConst) {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n  ;\n\n  _proto.parseTypeReference = function parseTypeReference() {\n    var start = this._lexer.token;\n    var type;\n\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      type = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = {\n        kind: Kind.LIST_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return {\n        kind: Kind.NON_NULL_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n  ;\n\n  _proto.parseNamedType = function parseNamedType() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Type Definition section.\n\n  /**\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n  ;\n\n  _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {\n    // Many definitions begin with a description and require a lookahead.\n    var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  };\n\n  _proto.peekDescription = function peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  /**\n   * Description : StringValue\n   */\n  ;\n\n  _proto.parseDescription = function parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n   */\n  ;\n\n  _proto.parseSchemaDefinition = function parseSchemaDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n    return {\n      kind: Kind.SCHEMA_DEFINITION,\n      description: description,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n  ;\n\n  _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {\n    var start = this._lexer.token;\n    var operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseNamedType();\n    return {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation: operation,\n      type: type,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n  ;\n\n  _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n  ;\n\n  _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n  ;\n\n  _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {\n    var types = [];\n\n    if (this.expectOptionalKeyword('implements')) {\n      // Optional leading ampersand\n      this.expectOptionalToken(TokenKind.AMP);\n\n      do {\n        var _this$_options2;\n\n        types.push(this.parseNamedType());\n      } while (this.expectOptionalToken(TokenKind.AMP) || // Legacy support for the SDL?\n      ((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.allowLegacySDLImplementsInterfaces) === true && this.peek(TokenKind.NAME));\n    }\n\n    return types;\n  }\n  /**\n   * FieldsDefinition : { FieldDefinition+ }\n   */\n  ;\n\n  _proto.parseFieldsDefinition = function parseFieldsDefinition() {\n    var _this$_options3;\n\n    // Legacy support for the SDL?\n    if (((_this$_options3 = this._options) === null || _this$_options3 === void 0 ? void 0 : _this$_options3.allowLegacySDLEmptyFields) === true && this.peek(TokenKind.BRACE_L) && this._lexer.lookahead().kind === TokenKind.BRACE_R) {\n      this._lexer.advance();\n\n      this._lexer.advance();\n\n      return [];\n    }\n\n    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n  ;\n\n  _proto.parseFieldDefinition = function parseFieldDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.FIELD_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      type: type,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n  ;\n\n  _proto.parseArgumentDefs = function parseArgumentDefs() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n  ;\n\n  _proto.parseInputValueDef = function parseInputValueDef() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var defaultValue;\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseValueLiteral(true);\n    }\n\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      type: type,\n      defaultValue: defaultValue,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n  ;\n\n  _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n  ;\n\n  _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n    return {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n  ;\n\n  _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {\n    var types = [];\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      // Optional leading pipe\n      this.expectOptionalToken(TokenKind.PIPE);\n\n      do {\n        types.push(this.parseNamedType());\n      } while (this.expectOptionalToken(TokenKind.PIPE));\n    }\n\n    return types;\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n  ;\n\n  _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n    return {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   */\n  ;\n\n  _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   *\n   * EnumValue : Name\n   */\n  ;\n\n  _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n  ;\n\n  _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   */\n  ;\n\n  _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n  ;\n\n  _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {\n    var keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   */\n  ;\n\n  _proto.parseSchemaExtension = function parseSchemaExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n  ;\n\n  _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n  ;\n\n  _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InterfaceTypeExtension :\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\n   *  - extend interface Name ImplementsInterfaces\n   */\n  ;\n\n  _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n  ;\n\n  _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n  ;\n\n  _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n  ;\n\n  _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   */\n  ;\n\n  _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    var repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    var locations = this.parseDirectiveLocations();\n    return {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      repeatable: repeatable,\n      locations: locations,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n  ;\n\n  _proto.parseDirectiveLocations = function parseDirectiveLocations() {\n    // Optional leading pipe\n    this.expectOptionalToken(TokenKind.PIPE);\n    var locations = [];\n\n    do {\n      locations.push(this.parseDirectiveLocation());\n    } while (this.expectOptionalToken(TokenKind.PIPE));\n\n    return locations;\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n  ;\n\n  _proto.parseDirectiveLocation = function parseDirectiveLocation() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n\n    if (DirectiveLocation[name.value] !== undefined) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a location object, used to identify the place in\n   * the source that created a given parsed object.\n   */\n  ;\n\n  _proto.loc = function loc(startToken) {\n    var _this$_options4;\n\n    if (((_this$_options4 = this._options) === null || _this$_options4 === void 0 ? void 0 : _this$_options4.noLocation) !== true) {\n      return new Location(startToken, this._lexer.lastToken, this._lexer.source);\n    }\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n  ;\n\n  _proto.peek = function peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing\n   * the lexer. Otherwise, do not change the parser state and throw an error.\n   */\n  ;\n\n  _proto.expectToken = function expectToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    throw syntaxError(this._lexer.source, token.start, \"Expected \".concat(getTokenKindDesc(kind), \", found \").concat(getTokenDesc(token), \".\"));\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing\n   * the lexer. Otherwise, do not change the parser state and return undefined.\n   */\n  ;\n\n  _proto.expectOptionalToken = function expectOptionalToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    return undefined;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n  ;\n\n  _proto.expectKeyword = function expectKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n    } else {\n      throw syntaxError(this._lexer.source, token.start, \"Expected \\\"\".concat(value, \"\\\", found \").concat(getTokenDesc(token), \".\"));\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing\n   * the lexer. Otherwise, do not change the parser state and return \"false\".\n   */\n  ;\n\n  _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token\n   * is encountered.\n   */\n  ;\n\n  _proto.unexpected = function unexpected(atToken) {\n    var token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return syntaxError(this._lexer.source, token.start, \"Unexpected \".concat(getTokenDesc(token), \".\"));\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by\n   * the parseFn. This list begins with a lex token of openKind\n   * and ends with a lex token of closeKind. Advances the parser\n   * to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.any = function any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always\n   * return non-empty list that begins with a lex token of openKind and ends\n   * with a lex token of closeKind. Advances the parser to the next lex token\n   * after the closing token.\n   */\n  ;\n\n  _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      var nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by\n   * the parseFn. This list begins with a lex token of openKind\n   * and ends with a lex token of closeKind. Advances the parser\n   * to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.many = function many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  };\n\n  return Parser;\n}();\n/**\n * A helper function to describe a token as a string for debugging\n */\n\n\nfunction getTokenDesc(token) {\n  var value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? \" \\\"\".concat(value, \"\\\"\") : '');\n}\n/**\n * A helper function to describe a token kind as a string for debugging\n */\n\n\nfunction getTokenKindDesc(kind) {\n  return isPunctuatorTokenKind(kind) ? \"\\\"\".concat(kind, \"\\\"\") : kind;\n}\n"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,wBAApB;AACA,OAAOC,SAAP,MAAsB,0BAAtB;AACA,SAASC,WAAT,QAA4B,0BAA5B;AACA,SAASC,IAAT,QAAqB,aAArB;AACA,SAASC,QAAT,QAAyB,WAAzB;AACA,SAASC,MAAT,QAAuB,cAAvB;AACA,SAASC,SAAT,QAA0B,iBAA1B;AACA,SAASC,iBAAT,QAAkC,yBAAlC;AACA,SAASC,KAAT,EAAgBC,qBAAhB,QAA6C,aAA7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA,OAAO,SAASC,KAAT,CAAeC,MAAf,EAAuBC,OAAvB,EAAgC;EACrC,IAAIC,MAAM,GAAG,IAAIC,MAAJ,CAAWH,MAAX,EAAmBC,OAAnB,CAAb;EACA,OAAOC,MAAM,CAACE,aAAP,EAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,UAAT,CAAoBL,MAApB,EAA4BC,OAA5B,EAAqC;EAC1C,IAAIC,MAAM,GAAG,IAAIC,MAAJ,CAAWH,MAAX,EAAmBC,OAAnB,CAAb;EACAC,MAAM,CAACI,WAAP,CAAmBX,SAAS,CAACY,GAA7B;EACA,IAAIC,KAAK,GAAGN,MAAM,CAACO,iBAAP,CAAyB,KAAzB,CAAZ;EACAP,MAAM,CAACI,WAAP,CAAmBX,SAAS,CAACe,GAA7B;EACA,OAAOF,KAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASG,SAAT,CAAmBX,MAAnB,EAA2BC,OAA3B,EAAoC;EACzC,IAAIC,MAAM,GAAG,IAAIC,MAAJ,CAAWH,MAAX,EAAmBC,OAAnB,CAAb;EACAC,MAAM,CAACI,WAAP,CAAmBX,SAAS,CAACY,GAA7B;EACA,IAAIK,IAAI,GAAGV,MAAM,CAACW,kBAAP,EAAX;EACAX,MAAM,CAACI,WAAP,CAAmBX,SAAS,CAACe,GAA7B;EACA,OAAOE,IAAP;AACD;;AAED,IAAIT,MAAM,GAAG,aAAa,YAAY;EACpC,SAASA,MAAT,CAAgBH,MAAhB,EAAwBC,OAAxB,EAAiC;IAC/B,IAAIa,SAAS,GAAG,OAAOd,MAAP,KAAkB,QAAlB,GAA6B,IAAIN,MAAJ,CAAWM,MAAX,CAA7B,GAAkDA,MAAlE;IACAc,SAAS,YAAYpB,MAArB,IAA+BJ,SAAS,CAAC,CAAD,EAAI,kCAAkCyB,MAAlC,CAAyC1B,OAAO,CAACyB,SAAD,CAAhD,EAA6D,GAA7D,CAAJ,CAAxC;IACA,KAAKE,MAAL,GAAc,IAAInB,KAAJ,CAAUiB,SAAV,CAAd;IACA,KAAKG,QAAL,GAAgBhB,OAAhB;EACD;EACD;AACF;AACA;;;EAGE,IAAIiB,MAAM,GAAGf,MAAM,CAACgB,SAApB;;EAEAD,MAAM,CAACE,SAAP,GAAmB,SAASA,SAAT,GAAqB;IACtC,IAAIC,KAAK,GAAG,KAAKf,WAAL,CAAiBX,SAAS,CAAC2B,IAA3B,CAAZ;IACA,OAAO;MACLC,IAAI,EAAE/B,IAAI,CAAC8B,IADN;MAELd,KAAK,EAAEa,KAAK,CAACb,KAFR;MAGLgB,GAAG,EAAE,KAAKA,GAAL,CAASH,KAAT;IAHA,CAAP;EAKD,CAPD,CAOE;;EAEF;AACF;AACA;EAXE;;EAcAH,MAAM,CAACd,aAAP,GAAuB,SAASA,aAAT,GAAyB;IAC9C,IAAIqB,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,OAAO;MACLE,IAAI,EAAE/B,IAAI,CAACkC,QADN;MAELC,WAAW,EAAE,KAAKC,IAAL,CAAUjC,SAAS,CAACY,GAApB,EAAyB,KAAKsB,eAA9B,EAA+ClC,SAAS,CAACe,GAAzD,CAFR;MAGLc,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IAHA,CAAP;EAKD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAjBE;;EAoBAP,MAAM,CAACW,eAAP,GAAyB,SAASA,eAAT,GAA2B;IAClD,IAAI,KAAKC,IAAL,CAAUnC,SAAS,CAAC2B,IAApB,CAAJ,EAA+B;MAC7B,QAAQ,KAAKN,MAAL,CAAYK,KAAZ,CAAkBb,KAA1B;QACE,KAAK,OAAL;QACA,KAAK,UAAL;QACA,KAAK,cAAL;UACE,OAAO,KAAKuB,wBAAL,EAAP;;QAEF,KAAK,UAAL;UACE,OAAO,KAAKC,uBAAL,EAAP;;QAEF,KAAK,QAAL;QACA,KAAK,QAAL;QACA,KAAK,MAAL;QACA,KAAK,WAAL;QACA,KAAK,OAAL;QACA,KAAK,MAAL;QACA,KAAK,OAAL;QACA,KAAK,WAAL;UACE,OAAO,KAAKC,yBAAL,EAAP;;QAEF,KAAK,QAAL;UACE,OAAO,KAAKC,wBAAL,EAAP;MApBJ;IAsBD,CAvBD,MAuBO,IAAI,KAAKJ,IAAL,CAAUnC,SAAS,CAACwC,OAApB,CAAJ,EAAkC;MACvC,OAAO,KAAKJ,wBAAL,EAAP;IACD,CAFM,MAEA,IAAI,KAAKK,eAAL,EAAJ,EAA4B;MACjC,OAAO,KAAKH,yBAAL,EAAP;IACD;;IAED,MAAM,KAAKI,UAAL,EAAN;EACD,CA/BD,CA+BE;;EAEF;AACF;AACA;AACA;AACA;EArCE;;EAwCAnB,MAAM,CAACa,wBAAP,GAAkC,SAASA,wBAAT,GAAoC;IACpE,IAAIN,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;;IAEA,IAAI,KAAKS,IAAL,CAAUnC,SAAS,CAACwC,OAApB,CAAJ,EAAkC;MAChC,OAAO;QACLZ,IAAI,EAAE/B,IAAI,CAAC8C,oBADN;QAELC,SAAS,EAAE,OAFN;QAGLC,IAAI,EAAEC,SAHD;QAILC,mBAAmB,EAAE,EAJhB;QAKLC,UAAU,EAAE,EALP;QAMLC,YAAY,EAAE,KAAKC,iBAAL,EANT;QAOLrB,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;MAPA,CAAP;IASD;;IAED,IAAIc,SAAS,GAAG,KAAKO,kBAAL,EAAhB;IACA,IAAIN,IAAJ;;IAEA,IAAI,KAAKV,IAAL,CAAUnC,SAAS,CAAC2B,IAApB,CAAJ,EAA+B;MAC7BkB,IAAI,GAAG,KAAKpB,SAAL,EAAP;IACD;;IAED,OAAO;MACLG,IAAI,EAAE/B,IAAI,CAAC8C,oBADN;MAELC,SAAS,EAAEA,SAFN;MAGLC,IAAI,EAAEA,IAHD;MAILE,mBAAmB,EAAE,KAAKK,wBAAL,EAJhB;MAKLJ,UAAU,EAAE,KAAKK,eAAL,CAAqB,KAArB,CALP;MAMLJ,YAAY,EAAE,KAAKC,iBAAL,EANT;MAOLrB,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IAPA,CAAP;EASD;EACD;AACF;AACA;EAlCE;;EAqCAP,MAAM,CAAC4B,kBAAP,GAA4B,SAASA,kBAAT,GAA8B;IACxD,IAAIG,cAAc,GAAG,KAAK3C,WAAL,CAAiBX,SAAS,CAAC2B,IAA3B,CAArB;;IAEA,QAAQ2B,cAAc,CAACzC,KAAvB;MACE,KAAK,OAAL;QACE,OAAO,OAAP;;MAEF,KAAK,UAAL;QACE,OAAO,UAAP;;MAEF,KAAK,cAAL;QACE,OAAO,cAAP;IARJ;;IAWA,MAAM,KAAK6B,UAAL,CAAgBY,cAAhB,CAAN;EACD;EACD;AACF;AACA;EAlBE;;EAqBA/B,MAAM,CAAC6B,wBAAP,GAAkC,SAASA,wBAAT,GAAoC;IACpE,OAAO,KAAKG,YAAL,CAAkBvD,SAAS,CAACwD,OAA5B,EAAqC,KAAKC,uBAA1C,EAAmEzD,SAAS,CAAC0D,OAA7E,CAAP;EACD;EACD;AACF;AACA;EALE;;EAQAnC,MAAM,CAACkC,uBAAP,GAAiC,SAASA,uBAAT,GAAmC;IAClE,IAAI3B,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,OAAO;MACLE,IAAI,EAAE/B,IAAI,CAAC8D,mBADN;MAELC,QAAQ,EAAE,KAAKC,aAAL,EAFL;MAGL5C,IAAI,GAAG,KAAKN,WAAL,CAAiBX,SAAS,CAAC8D,KAA3B,GAAmC,KAAK5C,kBAAL,EAAtC,CAHC;MAIL6C,YAAY,EAAE,KAAKC,mBAAL,CAAyBhE,SAAS,CAACiE,MAAnC,IAA6C,KAAKnD,iBAAL,CAAuB,IAAvB,CAA7C,GAA4EgC,SAJrF;MAKLE,UAAU,EAAE,KAAKK,eAAL,CAAqB,IAArB,CALP;MAMLxB,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IANA,CAAP;EAQD;EACD;AACF;AACA;EAbE;;EAgBAP,MAAM,CAACsC,aAAP,GAAuB,SAASA,aAAT,GAAyB;IAC9C,IAAI/B,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,KAAKf,WAAL,CAAiBX,SAAS,CAACkE,MAA3B;IACA,OAAO;MACLtC,IAAI,EAAE/B,IAAI,CAACsE,QADN;MAELtB,IAAI,EAAE,KAAKpB,SAAL,EAFD;MAGLI,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IAHA,CAAP;EAKD;EACD;AACF;AACA;EAXE;;EAcAP,MAAM,CAAC2B,iBAAP,GAA2B,SAASA,iBAAT,GAA6B;IACtD,IAAIpB,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,OAAO;MACLE,IAAI,EAAE/B,IAAI,CAACuE,aADN;MAELC,UAAU,EAAE,KAAKpC,IAAL,CAAUjC,SAAS,CAACwC,OAApB,EAA6B,KAAK8B,cAAlC,EAAkDtE,SAAS,CAACuE,OAA5D,CAFP;MAGL1C,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IAHA,CAAP;EAKD;EACD;AACF;AACA;AACA;AACA;AACA;EAbE;;EAgBAP,MAAM,CAAC+C,cAAP,GAAwB,SAASA,cAAT,GAA0B;IAChD,OAAO,KAAKnC,IAAL,CAAUnC,SAAS,CAACwE,MAApB,IAA8B,KAAKC,aAAL,EAA9B,GAAqD,KAAKC,UAAL,EAA5D;EACD;EACD;AACF;AACA;AACA;AACA;EAPE;;EAUAnD,MAAM,CAACmD,UAAP,GAAoB,SAASA,UAAT,GAAsB;IACxC,IAAI5C,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,IAAIiD,WAAW,GAAG,KAAKlD,SAAL,EAAlB;IACA,IAAImD,KAAJ;IACA,IAAI/B,IAAJ;;IAEA,IAAI,KAAKmB,mBAAL,CAAyBhE,SAAS,CAAC8D,KAAnC,CAAJ,EAA+C;MAC7Cc,KAAK,GAAGD,WAAR;MACA9B,IAAI,GAAG,KAAKpB,SAAL,EAAP;IACD,CAHD,MAGO;MACLoB,IAAI,GAAG8B,WAAP;IACD;;IAED,OAAO;MACL/C,IAAI,EAAE/B,IAAI,CAACgF,KADN;MAELD,KAAK,EAAEA,KAFF;MAGL/B,IAAI,EAAEA,IAHD;MAILiC,SAAS,EAAE,KAAKC,cAAL,CAAoB,KAApB,CAJN;MAKL/B,UAAU,EAAE,KAAKK,eAAL,CAAqB,KAArB,CALP;MAMLJ,YAAY,EAAE,KAAKd,IAAL,CAAUnC,SAAS,CAACwC,OAApB,IAA+B,KAAKU,iBAAL,EAA/B,GAA0DJ,SANnE;MAOLjB,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IAPA,CAAP;EASD;EACD;AACF;AACA;EAzBE;;EA4BAP,MAAM,CAACwD,cAAP,GAAwB,SAASA,cAAT,CAAwBC,OAAxB,EAAiC;IACvD,IAAIC,IAAI,GAAGD,OAAO,GAAG,KAAKE,kBAAR,GAA6B,KAAKC,aAApD;IACA,OAAO,KAAK5B,YAAL,CAAkBvD,SAAS,CAACwD,OAA5B,EAAqCyB,IAArC,EAA2CjF,SAAS,CAAC0D,OAArD,CAAP;EACD;EACD;AACF;AACA;EANE;;EASAnC,MAAM,CAAC4D,aAAP,GAAuB,SAASA,aAAT,GAAyB;IAC9C,IAAIrD,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,IAAImB,IAAI,GAAG,KAAKpB,SAAL,EAAX;IACA,KAAKd,WAAL,CAAiBX,SAAS,CAAC8D,KAA3B;IACA,OAAO;MACLlC,IAAI,EAAE/B,IAAI,CAACuF,QADN;MAELvC,IAAI,EAAEA,IAFD;MAGLhC,KAAK,EAAE,KAAKC,iBAAL,CAAuB,KAAvB,CAHF;MAILe,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IAJA,CAAP;EAMD,CAVD;;EAYAP,MAAM,CAAC2D,kBAAP,GAA4B,SAASA,kBAAT,GAA8B;IACxD,IAAIpD,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,OAAO;MACLE,IAAI,EAAE/B,IAAI,CAACuF,QADN;MAELvC,IAAI,EAAE,KAAKpB,SAAL,EAFD;MAGLZ,KAAK,GAAG,KAAKF,WAAL,CAAiBX,SAAS,CAAC8D,KAA3B,GAAmC,KAAKhD,iBAAL,CAAuB,IAAvB,CAAtC,CAHA;MAILe,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IAJA,CAAP;EAMD,CARD,CAQE;;EAEF;AACF;AACA;AACA;AACA;AACA;AACA;EAhBE;;EAmBAP,MAAM,CAACkD,aAAP,GAAuB,SAASA,aAAT,GAAyB;IAC9C,IAAI3C,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,KAAKf,WAAL,CAAiBX,SAAS,CAACwE,MAA3B;IACA,IAAIa,gBAAgB,GAAG,KAAKC,qBAAL,CAA2B,IAA3B,CAAvB;;IAEA,IAAI,CAACD,gBAAD,IAAqB,KAAKlD,IAAL,CAAUnC,SAAS,CAAC2B,IAApB,CAAzB,EAAoD;MAClD,OAAO;QACLC,IAAI,EAAE/B,IAAI,CAAC0F,eADN;QAEL1C,IAAI,EAAE,KAAK2C,iBAAL,EAFD;QAGLxC,UAAU,EAAE,KAAKK,eAAL,CAAqB,KAArB,CAHP;QAILxB,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;MAJA,CAAP;IAMD;;IAED,OAAO;MACLF,IAAI,EAAE/B,IAAI,CAAC4F,eADN;MAELC,aAAa,EAAEL,gBAAgB,GAAG,KAAKM,cAAL,EAAH,GAA2B7C,SAFrD;MAGLE,UAAU,EAAE,KAAKK,eAAL,CAAqB,KAArB,CAHP;MAILJ,YAAY,EAAE,KAAKC,iBAAL,EAJT;MAKLrB,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IALA,CAAP;EAOD;EACD;AACF;AACA;AACA;AACA;AACA;EA3BE;;EA8BAP,MAAM,CAACc,uBAAP,GAAiC,SAASA,uBAAT,GAAmC;IAClE,IAAIuD,cAAJ;;IAEA,IAAI9D,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,KAAKmE,aAAL,CAAmB,UAAnB,EAJkE,CAIlC;IAChC;IACA;;IAEA,IAAI,CAAC,CAACD,cAAc,GAAG,KAAKtE,QAAvB,MAAqC,IAArC,IAA6CsE,cAAc,KAAK,KAAK,CAArE,GAAyE,KAAK,CAA9E,GAAkFA,cAAc,CAACE,6BAAlG,MAAqI,IAAzI,EAA+I;MAC7I,OAAO;QACLlE,IAAI,EAAE/B,IAAI,CAACkG,mBADN;QAELlD,IAAI,EAAE,KAAK2C,iBAAL,EAFD;QAGLzC,mBAAmB,EAAE,KAAKK,wBAAL,EAHhB;QAILsC,aAAa,GAAG,KAAKG,aAAL,CAAmB,IAAnB,GAA0B,KAAKF,cAAL,EAA7B,CAJR;QAKL3C,UAAU,EAAE,KAAKK,eAAL,CAAqB,KAArB,CALP;QAMLJ,YAAY,EAAE,KAAKC,iBAAL,EANT;QAOLrB,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;MAPA,CAAP;IASD;;IAED,OAAO;MACLF,IAAI,EAAE/B,IAAI,CAACkG,mBADN;MAELlD,IAAI,EAAE,KAAK2C,iBAAL,EAFD;MAGLE,aAAa,GAAG,KAAKG,aAAL,CAAmB,IAAnB,GAA0B,KAAKF,cAAL,EAA7B,CAHR;MAIL3C,UAAU,EAAE,KAAKK,eAAL,CAAqB,KAArB,CAJP;MAKLJ,YAAY,EAAE,KAAKC,iBAAL,EALT;MAMLrB,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IANA,CAAP;EAQD;EACD;AACF;AACA;EA/BE;;EAkCAP,MAAM,CAACiE,iBAAP,GAA2B,SAASA,iBAAT,GAA6B;IACtD,IAAI,KAAKnE,MAAL,CAAYK,KAAZ,CAAkBb,KAAlB,KAA4B,IAAhC,EAAsC;MACpC,MAAM,KAAK6B,UAAL,EAAN;IACD;;IAED,OAAO,KAAKjB,SAAL,EAAP;EACD,CAND,CAME;;EAEF;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAzBE;;EA4BAF,MAAM,CAACT,iBAAP,GAA2B,SAASA,iBAAT,CAA2BkE,OAA3B,EAAoC;IAC7D,IAAItD,KAAK,GAAG,KAAKL,MAAL,CAAYK,KAAxB;;IAEA,QAAQA,KAAK,CAACE,IAAd;MACE,KAAK5B,SAAS,CAACgG,SAAf;QACE,OAAO,KAAKC,SAAL,CAAejB,OAAf,CAAP;;MAEF,KAAKhF,SAAS,CAACwC,OAAf;QACE,OAAO,KAAK0D,WAAL,CAAiBlB,OAAjB,CAAP;;MAEF,KAAKhF,SAAS,CAACmG,GAAf;QACE,KAAK9E,MAAL,CAAY+E,OAAZ;;QAEA,OAAO;UACLxE,IAAI,EAAE/B,IAAI,CAACsG,GADN;UAELtF,KAAK,EAAEa,KAAK,CAACb,KAFR;UAGLgB,GAAG,EAAE,KAAKA,GAAL,CAASH,KAAT;QAHA,CAAP;;MAMF,KAAK1B,SAAS,CAACqG,KAAf;QACE,KAAKhF,MAAL,CAAY+E,OAAZ;;QAEA,OAAO;UACLxE,IAAI,EAAE/B,IAAI,CAACwG,KADN;UAELxF,KAAK,EAAEa,KAAK,CAACb,KAFR;UAGLgB,GAAG,EAAE,KAAKA,GAAL,CAASH,KAAT;QAHA,CAAP;;MAMF,KAAK1B,SAAS,CAACsG,MAAf;MACA,KAAKtG,SAAS,CAACuG,YAAf;QACE,OAAO,KAAKC,kBAAL,EAAP;;MAEF,KAAKxG,SAAS,CAAC2B,IAAf;QACE,KAAKN,MAAL,CAAY+E,OAAZ;;QAEA,QAAQ1E,KAAK,CAACb,KAAd;UACE,KAAK,MAAL;YACE,OAAO;cACLe,IAAI,EAAE/B,IAAI,CAAC4G,OADN;cAEL5F,KAAK,EAAE,IAFF;cAGLgB,GAAG,EAAE,KAAKA,GAAL,CAASH,KAAT;YAHA,CAAP;;UAMF,KAAK,OAAL;YACE,OAAO;cACLE,IAAI,EAAE/B,IAAI,CAAC4G,OADN;cAEL5F,KAAK,EAAE,KAFF;cAGLgB,GAAG,EAAE,KAAKA,GAAL,CAASH,KAAT;YAHA,CAAP;;UAMF,KAAK,MAAL;YACE,OAAO;cACLE,IAAI,EAAE/B,IAAI,CAAC6G,IADN;cAEL7E,GAAG,EAAE,KAAKA,GAAL,CAASH,KAAT;YAFA,CAAP;;UAKF;YACE,OAAO;cACLE,IAAI,EAAE/B,IAAI,CAAC8G,IADN;cAEL9F,KAAK,EAAEa,KAAK,CAACb,KAFR;cAGLgB,GAAG,EAAE,KAAKA,GAAL,CAASH,KAAT;YAHA,CAAP;QAtBJ;;MA6BF,KAAK1B,SAAS,CAACkE,MAAf;QACE,IAAI,CAACc,OAAL,EAAc;UACZ,OAAO,KAAKnB,aAAL,EAAP;QACD;;QAED;IAlEJ;;IAqEA,MAAM,KAAKnB,UAAL,EAAN;EACD,CAzED;;EA2EAnB,MAAM,CAACiF,kBAAP,GAA4B,SAASA,kBAAT,GAA8B;IACxD,IAAI9E,KAAK,GAAG,KAAKL,MAAL,CAAYK,KAAxB;;IAEA,KAAKL,MAAL,CAAY+E,OAAZ;;IAEA,OAAO;MACLxE,IAAI,EAAE/B,IAAI,CAACyG,MADN;MAELzF,KAAK,EAAEa,KAAK,CAACb,KAFR;MAGL+F,KAAK,EAAElF,KAAK,CAACE,IAAN,KAAe5B,SAAS,CAACuG,YAH3B;MAIL1E,GAAG,EAAE,KAAKA,GAAL,CAASH,KAAT;IAJA,CAAP;EAMD;EACD;AACF;AACA;AACA;AACA;EAhBE;;EAmBAH,MAAM,CAAC0E,SAAP,GAAmB,SAASA,SAAT,CAAmBjB,OAAnB,EAA4B;IAC7C,IAAI6B,KAAK,GAAG,IAAZ;;IAEA,IAAI/E,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;;IAEA,IAAIuD,IAAI,GAAG,SAASA,IAAT,GAAgB;MACzB,OAAO4B,KAAK,CAAC/F,iBAAN,CAAwBkE,OAAxB,CAAP;IACD,CAFD;;IAIA,OAAO;MACLpD,IAAI,EAAE/B,IAAI,CAACiH,IADN;MAELC,MAAM,EAAE,KAAKC,GAAL,CAAShH,SAAS,CAACgG,SAAnB,EAA8Bf,IAA9B,EAAoCjF,SAAS,CAACiH,SAA9C,CAFH;MAGLpF,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IAHA,CAAP;EAKD;EACD;AACF;AACA;AACA;AACA;EAnBE;;EAsBAP,MAAM,CAAC2E,WAAP,GAAqB,SAASA,WAAT,CAAqBlB,OAArB,EAA8B;IACjD,IAAIkC,MAAM,GAAG,IAAb;;IAEA,IAAIpF,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;;IAEA,IAAIuD,IAAI,GAAG,SAASA,IAAT,GAAgB;MACzB,OAAOiC,MAAM,CAACC,gBAAP,CAAwBnC,OAAxB,CAAP;IACD,CAFD;;IAIA,OAAO;MACLpD,IAAI,EAAE/B,IAAI,CAACuH,MADN;MAELC,MAAM,EAAE,KAAKL,GAAL,CAAShH,SAAS,CAACwC,OAAnB,EAA4ByC,IAA5B,EAAkCjF,SAAS,CAACuE,OAA5C,CAFH;MAGL1C,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IAHA,CAAP;EAKD;EACD;AACF;AACA;EAjBE;;EAoBAP,MAAM,CAAC4F,gBAAP,GAA0B,SAASA,gBAAT,CAA0BnC,OAA1B,EAAmC;IAC3D,IAAIlD,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,IAAImB,IAAI,GAAG,KAAKpB,SAAL,EAAX;IACA,KAAKd,WAAL,CAAiBX,SAAS,CAAC8D,KAA3B;IACA,OAAO;MACLlC,IAAI,EAAE/B,IAAI,CAACyH,YADN;MAELzE,IAAI,EAAEA,IAFD;MAGLhC,KAAK,EAAE,KAAKC,iBAAL,CAAuBkE,OAAvB,CAHF;MAILnD,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IAJA,CAAP;EAMD,CAVD,CAUE;;EAEF;AACF;AACA;EAdE;;EAiBAP,MAAM,CAAC8B,eAAP,GAAyB,SAASA,eAAT,CAAyB2B,OAAzB,EAAkC;IACzD,IAAIhC,UAAU,GAAG,EAAjB;;IAEA,OAAO,KAAKb,IAAL,CAAUnC,SAAS,CAACuH,EAApB,CAAP,EAAgC;MAC9BvE,UAAU,CAACwE,IAAX,CAAgB,KAAKC,cAAL,CAAoBzC,OAApB,CAAhB;IACD;;IAED,OAAOhC,UAAP;EACD;EACD;AACF;AACA;EAXE;;EAcAzB,MAAM,CAACkG,cAAP,GAAwB,SAASA,cAAT,CAAwBzC,OAAxB,EAAiC;IACvD,IAAIlD,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,KAAKf,WAAL,CAAiBX,SAAS,CAACuH,EAA3B;IACA,OAAO;MACL3F,IAAI,EAAE/B,IAAI,CAAC6H,SADN;MAEL7E,IAAI,EAAE,KAAKpB,SAAL,EAFD;MAGLqD,SAAS,EAAE,KAAKC,cAAL,CAAoBC,OAApB,CAHN;MAILnD,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IAJA,CAAP;EAMD,CATD,CASE;;EAEF;AACF;AACA;AACA;AACA;AACA;EAhBE;;EAmBAP,MAAM,CAACL,kBAAP,GAA4B,SAASA,kBAAT,GAA8B;IACxD,IAAIY,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,IAAIT,IAAJ;;IAEA,IAAI,KAAK+C,mBAAL,CAAyBhE,SAAS,CAACgG,SAAnC,CAAJ,EAAmD;MACjD/E,IAAI,GAAG,KAAKC,kBAAL,EAAP;MACA,KAAKP,WAAL,CAAiBX,SAAS,CAACiH,SAA3B;MACAhG,IAAI,GAAG;QACLW,IAAI,EAAE/B,IAAI,CAAC8H,SADN;QAEL1G,IAAI,EAAEA,IAFD;QAGLY,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;MAHA,CAAP;IAKD,CARD,MAQO;MACLb,IAAI,GAAG,KAAK0E,cAAL,EAAP;IACD;;IAED,IAAI,KAAK3B,mBAAL,CAAyBhE,SAAS,CAAC4H,IAAnC,CAAJ,EAA8C;MAC5C,OAAO;QACLhG,IAAI,EAAE/B,IAAI,CAACgI,aADN;QAEL5G,IAAI,EAAEA,IAFD;QAGLY,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;MAHA,CAAP;IAKD;;IAED,OAAOb,IAAP;EACD;EACD;AACF;AACA;EA5BE;;EA+BAM,MAAM,CAACoE,cAAP,GAAwB,SAASA,cAAT,GAA0B;IAChD,IAAI7D,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,OAAO;MACLE,IAAI,EAAE/B,IAAI,CAACiI,UADN;MAELjF,IAAI,EAAE,KAAKpB,SAAL,EAFD;MAGLI,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IAHA,CAAP;EAKD,CAPD,CAOE;;EAEF;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAtBE;;EAyBAP,MAAM,CAACe,yBAAP,GAAmC,SAASA,yBAAT,GAAqC;IACtE;IACA,IAAIyF,YAAY,GAAG,KAAKtF,eAAL,KAAyB,KAAKpB,MAAL,CAAY2G,SAAZ,EAAzB,GAAmD,KAAK3G,MAAL,CAAYK,KAAlF;;IAEA,IAAIqG,YAAY,CAACnG,IAAb,KAAsB5B,SAAS,CAAC2B,IAApC,EAA0C;MACxC,QAAQoG,YAAY,CAAClH,KAArB;QACE,KAAK,QAAL;UACE,OAAO,KAAKoH,qBAAL,EAAP;;QAEF,KAAK,QAAL;UACE,OAAO,KAAKC,yBAAL,EAAP;;QAEF,KAAK,MAAL;UACE,OAAO,KAAKC,yBAAL,EAAP;;QAEF,KAAK,WAAL;UACE,OAAO,KAAKC,4BAAL,EAAP;;QAEF,KAAK,OAAL;UACE,OAAO,KAAKC,wBAAL,EAAP;;QAEF,KAAK,MAAL;UACE,OAAO,KAAKC,uBAAL,EAAP;;QAEF,KAAK,OAAL;UACE,OAAO,KAAKC,8BAAL,EAAP;;QAEF,KAAK,WAAL;UACE,OAAO,KAAKC,wBAAL,EAAP;MAvBJ;IAyBD;;IAED,MAAM,KAAK9F,UAAL,CAAgBqF,YAAhB,CAAN;EACD,CAjCD;;EAmCAxG,MAAM,CAACkB,eAAP,GAAyB,SAASA,eAAT,GAA2B;IAClD,OAAO,KAAKN,IAAL,CAAUnC,SAAS,CAACsG,MAApB,KAA+B,KAAKnE,IAAL,CAAUnC,SAAS,CAACuG,YAApB,CAAtC;EACD;EACD;AACF;AACA;EALE;;EAQAhF,MAAM,CAACkH,gBAAP,GAA0B,SAASA,gBAAT,GAA4B;IACpD,IAAI,KAAKhG,eAAL,EAAJ,EAA4B;MAC1B,OAAO,KAAK+D,kBAAL,EAAP;IACD;EACF;EACD;AACF;AACA;EAPE;;EAUAjF,MAAM,CAAC0G,qBAAP,GAA+B,SAASA,qBAAT,GAAiC;IAC9D,IAAInG,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,IAAIgH,WAAW,GAAG,KAAKD,gBAAL,EAAlB;IACA,KAAK5C,aAAL,CAAmB,QAAnB;IACA,IAAI7C,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;IACA,IAAIsF,cAAc,GAAG,KAAK1G,IAAL,CAAUjC,SAAS,CAACwC,OAApB,EAA6B,KAAKoG,4BAAlC,EAAgE5I,SAAS,CAACuE,OAA1E,CAArB;IACA,OAAO;MACL3C,IAAI,EAAE/B,IAAI,CAACgJ,iBADN;MAELH,WAAW,EAAEA,WAFR;MAGL1F,UAAU,EAAEA,UAHP;MAIL2F,cAAc,EAAEA,cAJX;MAKL9G,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IALA,CAAP;EAOD;EACD;AACF;AACA;EAhBE;;EAmBAP,MAAM,CAACqH,4BAAP,GAAsC,SAASA,4BAAT,GAAwC;IAC5E,IAAI9G,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,IAAIkB,SAAS,GAAG,KAAKO,kBAAL,EAAhB;IACA,KAAKxC,WAAL,CAAiBX,SAAS,CAAC8D,KAA3B;IACA,IAAI7C,IAAI,GAAG,KAAK0E,cAAL,EAAX;IACA,OAAO;MACL/D,IAAI,EAAE/B,IAAI,CAACiJ,yBADN;MAELlG,SAAS,EAAEA,SAFN;MAGL3B,IAAI,EAAEA,IAHD;MAILY,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IAJA,CAAP;EAMD;EACD;AACF;AACA;EAdE;;EAiBAP,MAAM,CAAC2G,yBAAP,GAAmC,SAASA,yBAAT,GAAqC;IACtE,IAAIpG,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,IAAIgH,WAAW,GAAG,KAAKD,gBAAL,EAAlB;IACA,KAAK5C,aAAL,CAAmB,QAAnB;IACA,IAAIhD,IAAI,GAAG,KAAKpB,SAAL,EAAX;IACA,IAAIuB,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;IACA,OAAO;MACLzB,IAAI,EAAE/B,IAAI,CAACkJ,sBADN;MAELL,WAAW,EAAEA,WAFR;MAGL7F,IAAI,EAAEA,IAHD;MAILG,UAAU,EAAEA,UAJP;MAKLnB,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IALA,CAAP;EAOD;EACD;AACF;AACA;AACA;AACA;EAlBE;;EAqBAP,MAAM,CAAC4G,yBAAP,GAAmC,SAASA,yBAAT,GAAqC;IACtE,IAAIrG,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,IAAIgH,WAAW,GAAG,KAAKD,gBAAL,EAAlB;IACA,KAAK5C,aAAL,CAAmB,MAAnB;IACA,IAAIhD,IAAI,GAAG,KAAKpB,SAAL,EAAX;IACA,IAAIuH,UAAU,GAAG,KAAKC,yBAAL,EAAjB;IACA,IAAIjG,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;IACA,IAAIgE,MAAM,GAAG,KAAK6B,qBAAL,EAAb;IACA,OAAO;MACLtH,IAAI,EAAE/B,IAAI,CAACsJ,sBADN;MAELT,WAAW,EAAEA,WAFR;MAGL7F,IAAI,EAAEA,IAHD;MAILmG,UAAU,EAAEA,UAJP;MAKLhG,UAAU,EAAEA,UALP;MAMLqE,MAAM,EAAEA,MANH;MAOLxF,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IAPA,CAAP;EASD;EACD;AACF;AACA;AACA;AACA;EAtBE;;EAyBAP,MAAM,CAAC0H,yBAAP,GAAmC,SAASA,yBAAT,GAAqC;IACtE,IAAIG,KAAK,GAAG,EAAZ;;IAEA,IAAI,KAAK9D,qBAAL,CAA2B,YAA3B,CAAJ,EAA8C;MAC5C;MACA,KAAKtB,mBAAL,CAAyBhE,SAAS,CAACqJ,GAAnC;;MAEA,GAAG;QACD,IAAIC,eAAJ;;QAEAF,KAAK,CAAC5B,IAAN,CAAW,KAAK7B,cAAL,EAAX;MACD,CAJD,QAIS,KAAK3B,mBAAL,CAAyBhE,SAAS,CAACqJ,GAAnC,KAA2C;MACpD,CAAC,CAACC,eAAe,GAAG,KAAKhI,QAAxB,MAAsC,IAAtC,IAA8CgI,eAAe,KAAK,KAAK,CAAvE,GAA2E,KAAK,CAAhF,GAAoFA,eAAe,CAACC,kCAArG,MAA6I,IAA7I,IAAqJ,KAAKpH,IAAL,CAAUnC,SAAS,CAAC2B,IAApB,CALrJ;IAMD;;IAED,OAAOyH,KAAP;EACD;EACD;AACF;AACA;EAnBE;;EAsBA7H,MAAM,CAAC2H,qBAAP,GAA+B,SAASA,qBAAT,GAAiC;IAC9D,IAAIM,eAAJ,CAD8D,CAG9D;;;IACA,IAAI,CAAC,CAACA,eAAe,GAAG,KAAKlI,QAAxB,MAAsC,IAAtC,IAA8CkI,eAAe,KAAK,KAAK,CAAvE,GAA2E,KAAK,CAAhF,GAAoFA,eAAe,CAACC,yBAArG,MAAoI,IAApI,IAA4I,KAAKtH,IAAL,CAAUnC,SAAS,CAACwC,OAApB,CAA5I,IAA4K,KAAKnB,MAAL,CAAY2G,SAAZ,GAAwBpG,IAAxB,KAAiC5B,SAAS,CAACuE,OAA3N,EAAoO;MAClO,KAAKlD,MAAL,CAAY+E,OAAZ;;MAEA,KAAK/E,MAAL,CAAY+E,OAAZ;;MAEA,OAAO,EAAP;IACD;;IAED,OAAO,KAAK7C,YAAL,CAAkBvD,SAAS,CAACwC,OAA5B,EAAqC,KAAKkH,oBAA1C,EAAgE1J,SAAS,CAACuE,OAA1E,CAAP;EACD;EACD;AACF;AACA;AACA;EAjBE;;EAoBAhD,MAAM,CAACmI,oBAAP,GAA8B,SAASA,oBAAT,GAAgC;IAC5D,IAAI5H,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,IAAIgH,WAAW,GAAG,KAAKD,gBAAL,EAAlB;IACA,IAAI5F,IAAI,GAAG,KAAKpB,SAAL,EAAX;IACA,IAAIkI,IAAI,GAAG,KAAKC,iBAAL,EAAX;IACA,KAAKjJ,WAAL,CAAiBX,SAAS,CAAC8D,KAA3B;IACA,IAAI7C,IAAI,GAAG,KAAKC,kBAAL,EAAX;IACA,IAAI8B,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;IACA,OAAO;MACLzB,IAAI,EAAE/B,IAAI,CAACgK,gBADN;MAELnB,WAAW,EAAEA,WAFR;MAGL7F,IAAI,EAAEA,IAHD;MAILiC,SAAS,EAAE6E,IAJN;MAKL1I,IAAI,EAAEA,IALD;MAML+B,UAAU,EAAEA,UANP;MAOLnB,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IAPA,CAAP;EASD;EACD;AACF;AACA;EApBE;;EAuBAP,MAAM,CAACqI,iBAAP,GAA2B,SAASA,iBAAT,GAA6B;IACtD,OAAO,KAAKrG,YAAL,CAAkBvD,SAAS,CAACwD,OAA5B,EAAqC,KAAKsG,kBAA1C,EAA8D9J,SAAS,CAAC0D,OAAxE,CAAP;EACD;EACD;AACF;AACA;AACA;EANE;;EASAnC,MAAM,CAACuI,kBAAP,GAA4B,SAASA,kBAAT,GAA8B;IACxD,IAAIhI,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,IAAIgH,WAAW,GAAG,KAAKD,gBAAL,EAAlB;IACA,IAAI5F,IAAI,GAAG,KAAKpB,SAAL,EAAX;IACA,KAAKd,WAAL,CAAiBX,SAAS,CAAC8D,KAA3B;IACA,IAAI7C,IAAI,GAAG,KAAKC,kBAAL,EAAX;IACA,IAAI6C,YAAJ;;IAEA,IAAI,KAAKC,mBAAL,CAAyBhE,SAAS,CAACiE,MAAnC,CAAJ,EAAgD;MAC9CF,YAAY,GAAG,KAAKjD,iBAAL,CAAuB,IAAvB,CAAf;IACD;;IAED,IAAIkC,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;IACA,OAAO;MACLzB,IAAI,EAAE/B,IAAI,CAACkK,sBADN;MAELrB,WAAW,EAAEA,WAFR;MAGL7F,IAAI,EAAEA,IAHD;MAIL5B,IAAI,EAAEA,IAJD;MAKL8C,YAAY,EAAEA,YALT;MAMLf,UAAU,EAAEA,UANP;MAOLnB,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IAPA,CAAP;EASD;EACD;AACF;AACA;AACA;EA1BE;;EA6BAP,MAAM,CAAC6G,4BAAP,GAAsC,SAASA,4BAAT,GAAwC;IAC5E,IAAItG,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,IAAIgH,WAAW,GAAG,KAAKD,gBAAL,EAAlB;IACA,KAAK5C,aAAL,CAAmB,WAAnB;IACA,IAAIhD,IAAI,GAAG,KAAKpB,SAAL,EAAX;IACA,IAAIuH,UAAU,GAAG,KAAKC,yBAAL,EAAjB;IACA,IAAIjG,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;IACA,IAAIgE,MAAM,GAAG,KAAK6B,qBAAL,EAAb;IACA,OAAO;MACLtH,IAAI,EAAE/B,IAAI,CAACmK,yBADN;MAELtB,WAAW,EAAEA,WAFR;MAGL7F,IAAI,EAAEA,IAHD;MAILmG,UAAU,EAAEA,UAJP;MAKLhG,UAAU,EAAEA,UALP;MAMLqE,MAAM,EAAEA,MANH;MAOLxF,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IAPA,CAAP;EASD;EACD;AACF;AACA;AACA;EArBE;;EAwBAP,MAAM,CAAC8G,wBAAP,GAAkC,SAASA,wBAAT,GAAoC;IACpE,IAAIvG,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,IAAIgH,WAAW,GAAG,KAAKD,gBAAL,EAAlB;IACA,KAAK5C,aAAL,CAAmB,OAAnB;IACA,IAAIhD,IAAI,GAAG,KAAKpB,SAAL,EAAX;IACA,IAAIuB,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;IACA,IAAI+F,KAAK,GAAG,KAAKa,qBAAL,EAAZ;IACA,OAAO;MACLrI,IAAI,EAAE/B,IAAI,CAACqK,qBADN;MAELxB,WAAW,EAAEA,WAFR;MAGL7F,IAAI,EAAEA,IAHD;MAILG,UAAU,EAAEA,UAJP;MAKLoG,KAAK,EAAEA,KALF;MAMLvH,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IANA,CAAP;EAQD;EACD;AACF;AACA;AACA;AACA;EApBE;;EAuBAP,MAAM,CAAC0I,qBAAP,GAA+B,SAASA,qBAAT,GAAiC;IAC9D,IAAIb,KAAK,GAAG,EAAZ;;IAEA,IAAI,KAAKpF,mBAAL,CAAyBhE,SAAS,CAACiE,MAAnC,CAAJ,EAAgD;MAC9C;MACA,KAAKD,mBAAL,CAAyBhE,SAAS,CAACmK,IAAnC;;MAEA,GAAG;QACDf,KAAK,CAAC5B,IAAN,CAAW,KAAK7B,cAAL,EAAX;MACD,CAFD,QAES,KAAK3B,mBAAL,CAAyBhE,SAAS,CAACmK,IAAnC,CAFT;IAGD;;IAED,OAAOf,KAAP;EACD;EACD;AACF;AACA;AACA;EAjBE;;EAoBA7H,MAAM,CAAC+G,uBAAP,GAAiC,SAASA,uBAAT,GAAmC;IAClE,IAAIxG,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,IAAIgH,WAAW,GAAG,KAAKD,gBAAL,EAAlB;IACA,KAAK5C,aAAL,CAAmB,MAAnB;IACA,IAAIhD,IAAI,GAAG,KAAKpB,SAAL,EAAX;IACA,IAAIuB,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;IACA,IAAI0D,MAAM,GAAG,KAAKqD,yBAAL,EAAb;IACA,OAAO;MACLxI,IAAI,EAAE/B,IAAI,CAACwK,oBADN;MAEL3B,WAAW,EAAEA,WAFR;MAGL7F,IAAI,EAAEA,IAHD;MAILG,UAAU,EAAEA,UAJP;MAKL+D,MAAM,EAAEA,MALH;MAMLlF,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IANA,CAAP;EAQD;EACD;AACF;AACA;EAlBE;;EAqBAP,MAAM,CAAC6I,yBAAP,GAAmC,SAASA,yBAAT,GAAqC;IACtE,OAAO,KAAK7G,YAAL,CAAkBvD,SAAS,CAACwC,OAA5B,EAAqC,KAAK8H,wBAA1C,EAAoEtK,SAAS,CAACuE,OAA9E,CAAP;EACD;EACD;AACF;AACA;AACA;AACA;EAPE;;EAUAhD,MAAM,CAAC+I,wBAAP,GAAkC,SAASA,wBAAT,GAAoC;IACpE,IAAIxI,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,IAAIgH,WAAW,GAAG,KAAKD,gBAAL,EAAlB;IACA,IAAI5F,IAAI,GAAG,KAAKpB,SAAL,EAAX;IACA,IAAIuB,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;IACA,OAAO;MACLzB,IAAI,EAAE/B,IAAI,CAAC0K,qBADN;MAEL7B,WAAW,EAAEA,WAFR;MAGL7F,IAAI,EAAEA,IAHD;MAILG,UAAU,EAAEA,UAJP;MAKLnB,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IALA,CAAP;EAOD;EACD;AACF;AACA;AACA;EAhBE;;EAmBAP,MAAM,CAACgH,8BAAP,GAAwC,SAASA,8BAAT,GAA0C;IAChF,IAAIzG,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,IAAIgH,WAAW,GAAG,KAAKD,gBAAL,EAAlB;IACA,KAAK5C,aAAL,CAAmB,OAAnB;IACA,IAAIhD,IAAI,GAAG,KAAKpB,SAAL,EAAX;IACA,IAAIuB,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;IACA,IAAIgE,MAAM,GAAG,KAAKmD,0BAAL,EAAb;IACA,OAAO;MACL5I,IAAI,EAAE/B,IAAI,CAAC4K,4BADN;MAEL/B,WAAW,EAAEA,WAFR;MAGL7F,IAAI,EAAEA,IAHD;MAILG,UAAU,EAAEA,UAJP;MAKLqE,MAAM,EAAEA,MALH;MAMLxF,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IANA,CAAP;EAQD;EACD;AACF;AACA;EAlBE;;EAqBAP,MAAM,CAACiJ,0BAAP,GAAoC,SAASA,0BAAT,GAAsC;IACxE,OAAO,KAAKjH,YAAL,CAAkBvD,SAAS,CAACwC,OAA5B,EAAqC,KAAKsH,kBAA1C,EAA8D9J,SAAS,CAACuE,OAAxE,CAAP;EACD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAfE;;EAkBAhD,MAAM,CAACgB,wBAAP,GAAkC,SAASA,wBAAT,GAAoC;IACpE,IAAIwF,YAAY,GAAG,KAAK1G,MAAL,CAAY2G,SAAZ,EAAnB;;IAEA,IAAID,YAAY,CAACnG,IAAb,KAAsB5B,SAAS,CAAC2B,IAApC,EAA0C;MACxC,QAAQoG,YAAY,CAAClH,KAArB;QACE,KAAK,QAAL;UACE,OAAO,KAAK6J,oBAAL,EAAP;;QAEF,KAAK,QAAL;UACE,OAAO,KAAKC,wBAAL,EAAP;;QAEF,KAAK,MAAL;UACE,OAAO,KAAKC,wBAAL,EAAP;;QAEF,KAAK,WAAL;UACE,OAAO,KAAKC,2BAAL,EAAP;;QAEF,KAAK,OAAL;UACE,OAAO,KAAKC,uBAAL,EAAP;;QAEF,KAAK,MAAL;UACE,OAAO,KAAKC,sBAAL,EAAP;;QAEF,KAAK,OAAL;UACE,OAAO,KAAKC,6BAAL,EAAP;MApBJ;IAsBD;;IAED,MAAM,KAAKtI,UAAL,CAAgBqF,YAAhB,CAAN;EACD;EACD;AACF;AACA;AACA;AACA;EAlCE;;EAqCAxG,MAAM,CAACmJ,oBAAP,GAA8B,SAASA,oBAAT,GAAgC;IAC5D,IAAI5I,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,KAAKmE,aAAL,CAAmB,QAAnB;IACA,KAAKA,aAAL,CAAmB,QAAnB;IACA,IAAI7C,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;IACA,IAAIsF,cAAc,GAAG,KAAKpF,YAAL,CAAkBvD,SAAS,CAACwC,OAA5B,EAAqC,KAAKoG,4BAA1C,EAAwE5I,SAAS,CAACuE,OAAlF,CAArB;;IAEA,IAAIvB,UAAU,CAACiI,MAAX,KAAsB,CAAtB,IAA2BtC,cAAc,CAACsC,MAAf,KAA0B,CAAzD,EAA4D;MAC1D,MAAM,KAAKvI,UAAL,EAAN;IACD;;IAED,OAAO;MACLd,IAAI,EAAE/B,IAAI,CAACqL,gBADN;MAELlI,UAAU,EAAEA,UAFP;MAGL2F,cAAc,EAAEA,cAHX;MAIL9G,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IAJA,CAAP;EAMD;EACD;AACF;AACA;AACA;EArBE;;EAwBAP,MAAM,CAACoJ,wBAAP,GAAkC,SAASA,wBAAT,GAAoC;IACpE,IAAI7I,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,KAAKmE,aAAL,CAAmB,QAAnB;IACA,KAAKA,aAAL,CAAmB,QAAnB;IACA,IAAIhD,IAAI,GAAG,KAAKpB,SAAL,EAAX;IACA,IAAIuB,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;;IAEA,IAAIL,UAAU,CAACiI,MAAX,KAAsB,CAA1B,EAA6B;MAC3B,MAAM,KAAKvI,UAAL,EAAN;IACD;;IAED,OAAO;MACLd,IAAI,EAAE/B,IAAI,CAACsL,qBADN;MAELtI,IAAI,EAAEA,IAFD;MAGLG,UAAU,EAAEA,UAHP;MAILnB,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IAJA,CAAP;EAMD;EACD;AACF;AACA;AACA;AACA;AACA;EAvBE;;EA0BAP,MAAM,CAACqJ,wBAAP,GAAkC,SAASA,wBAAT,GAAoC;IACpE,IAAI9I,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,KAAKmE,aAAL,CAAmB,QAAnB;IACA,KAAKA,aAAL,CAAmB,MAAnB;IACA,IAAIhD,IAAI,GAAG,KAAKpB,SAAL,EAAX;IACA,IAAIuH,UAAU,GAAG,KAAKC,yBAAL,EAAjB;IACA,IAAIjG,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;IACA,IAAIgE,MAAM,GAAG,KAAK6B,qBAAL,EAAb;;IAEA,IAAIF,UAAU,CAACiC,MAAX,KAAsB,CAAtB,IAA2BjI,UAAU,CAACiI,MAAX,KAAsB,CAAjD,IAAsD5D,MAAM,CAAC4D,MAAP,KAAkB,CAA5E,EAA+E;MAC7E,MAAM,KAAKvI,UAAL,EAAN;IACD;;IAED,OAAO;MACLd,IAAI,EAAE/B,IAAI,CAACuL,qBADN;MAELvI,IAAI,EAAEA,IAFD;MAGLmG,UAAU,EAAEA,UAHP;MAILhG,UAAU,EAAEA,UAJP;MAKLqE,MAAM,EAAEA,MALH;MAMLxF,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IANA,CAAP;EAQD;EACD;AACF;AACA;AACA;AACA;AACA;EA3BE;;EA8BAP,MAAM,CAACsJ,2BAAP,GAAqC,SAASA,2BAAT,GAAuC;IAC1E,IAAI/I,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,KAAKmE,aAAL,CAAmB,QAAnB;IACA,KAAKA,aAAL,CAAmB,WAAnB;IACA,IAAIhD,IAAI,GAAG,KAAKpB,SAAL,EAAX;IACA,IAAIuH,UAAU,GAAG,KAAKC,yBAAL,EAAjB;IACA,IAAIjG,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;IACA,IAAIgE,MAAM,GAAG,KAAK6B,qBAAL,EAAb;;IAEA,IAAIF,UAAU,CAACiC,MAAX,KAAsB,CAAtB,IAA2BjI,UAAU,CAACiI,MAAX,KAAsB,CAAjD,IAAsD5D,MAAM,CAAC4D,MAAP,KAAkB,CAA5E,EAA+E;MAC7E,MAAM,KAAKvI,UAAL,EAAN;IACD;;IAED,OAAO;MACLd,IAAI,EAAE/B,IAAI,CAACwL,wBADN;MAELxI,IAAI,EAAEA,IAFD;MAGLmG,UAAU,EAAEA,UAHP;MAILhG,UAAU,EAAEA,UAJP;MAKLqE,MAAM,EAAEA,MALH;MAMLxF,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IANA,CAAP;EAQD;EACD;AACF;AACA;AACA;AACA;EA1BE;;EA6BAP,MAAM,CAACuJ,uBAAP,GAAiC,SAASA,uBAAT,GAAmC;IAClE,IAAIhJ,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,KAAKmE,aAAL,CAAmB,QAAnB;IACA,KAAKA,aAAL,CAAmB,OAAnB;IACA,IAAIhD,IAAI,GAAG,KAAKpB,SAAL,EAAX;IACA,IAAIuB,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;IACA,IAAI+F,KAAK,GAAG,KAAKa,qBAAL,EAAZ;;IAEA,IAAIjH,UAAU,CAACiI,MAAX,KAAsB,CAAtB,IAA2B7B,KAAK,CAAC6B,MAAN,KAAiB,CAAhD,EAAmD;MACjD,MAAM,KAAKvI,UAAL,EAAN;IACD;;IAED,OAAO;MACLd,IAAI,EAAE/B,IAAI,CAACyL,oBADN;MAELzI,IAAI,EAAEA,IAFD;MAGLG,UAAU,EAAEA,UAHP;MAILoG,KAAK,EAAEA,KAJF;MAKLvH,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IALA,CAAP;EAOD;EACD;AACF;AACA;AACA;AACA;EAxBE;;EA2BAP,MAAM,CAACwJ,sBAAP,GAAgC,SAASA,sBAAT,GAAkC;IAChE,IAAIjJ,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,KAAKmE,aAAL,CAAmB,QAAnB;IACA,KAAKA,aAAL,CAAmB,MAAnB;IACA,IAAIhD,IAAI,GAAG,KAAKpB,SAAL,EAAX;IACA,IAAIuB,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;IACA,IAAI0D,MAAM,GAAG,KAAKqD,yBAAL,EAAb;;IAEA,IAAIpH,UAAU,CAACiI,MAAX,KAAsB,CAAtB,IAA2BlE,MAAM,CAACkE,MAAP,KAAkB,CAAjD,EAAoD;MAClD,MAAM,KAAKvI,UAAL,EAAN;IACD;;IAED,OAAO;MACLd,IAAI,EAAE/B,IAAI,CAAC0L,mBADN;MAEL1I,IAAI,EAAEA,IAFD;MAGLG,UAAU,EAAEA,UAHP;MAIL+D,MAAM,EAAEA,MAJH;MAKLlF,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IALA,CAAP;EAOD;EACD;AACF;AACA;AACA;AACA;EAxBE;;EA2BAP,MAAM,CAACyJ,6BAAP,GAAuC,SAASA,6BAAT,GAAyC;IAC9E,IAAIlJ,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,KAAKmE,aAAL,CAAmB,QAAnB;IACA,KAAKA,aAAL,CAAmB,OAAnB;IACA,IAAIhD,IAAI,GAAG,KAAKpB,SAAL,EAAX;IACA,IAAIuB,UAAU,GAAG,KAAKK,eAAL,CAAqB,IAArB,CAAjB;IACA,IAAIgE,MAAM,GAAG,KAAKmD,0BAAL,EAAb;;IAEA,IAAIxH,UAAU,CAACiI,MAAX,KAAsB,CAAtB,IAA2B5D,MAAM,CAAC4D,MAAP,KAAkB,CAAjD,EAAoD;MAClD,MAAM,KAAKvI,UAAL,EAAN;IACD;;IAED,OAAO;MACLd,IAAI,EAAE/B,IAAI,CAAC2L,2BADN;MAEL3I,IAAI,EAAEA,IAFD;MAGLG,UAAU,EAAEA,UAHP;MAILqE,MAAM,EAAEA,MAJH;MAKLxF,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IALA,CAAP;EAOD;EACD;AACF;AACA;AACA;EAvBE;;EA0BAP,MAAM,CAACiH,wBAAP,GAAkC,SAASA,wBAAT,GAAoC;IACpE,IAAI1G,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,IAAIgH,WAAW,GAAG,KAAKD,gBAAL,EAAlB;IACA,KAAK5C,aAAL,CAAmB,WAAnB;IACA,KAAKlF,WAAL,CAAiBX,SAAS,CAACuH,EAA3B;IACA,IAAI1E,IAAI,GAAG,KAAKpB,SAAL,EAAX;IACA,IAAIkI,IAAI,GAAG,KAAKC,iBAAL,EAAX;IACA,IAAI6B,UAAU,GAAG,KAAKnG,qBAAL,CAA2B,YAA3B,CAAjB;IACA,KAAKO,aAAL,CAAmB,IAAnB;IACA,IAAI6F,SAAS,GAAG,KAAKC,uBAAL,EAAhB;IACA,OAAO;MACL/J,IAAI,EAAE/B,IAAI,CAAC+L,oBADN;MAELlD,WAAW,EAAEA,WAFR;MAGL7F,IAAI,EAAEA,IAHD;MAILiC,SAAS,EAAE6E,IAJN;MAKL8B,UAAU,EAAEA,UALP;MAMLC,SAAS,EAAEA,SANN;MAOL7J,GAAG,EAAE,KAAKA,GAAL,CAASC,KAAT;IAPA,CAAP;EASD;EACD;AACF;AACA;AACA;AACA;EAxBE;;EA2BAP,MAAM,CAACoK,uBAAP,GAAiC,SAASA,uBAAT,GAAmC;IAClE;IACA,KAAK3H,mBAAL,CAAyBhE,SAAS,CAACmK,IAAnC;IACA,IAAIuB,SAAS,GAAG,EAAhB;;IAEA,GAAG;MACDA,SAAS,CAAClE,IAAV,CAAe,KAAKqE,sBAAL,EAAf;IACD,CAFD,QAES,KAAK7H,mBAAL,CAAyBhE,SAAS,CAACmK,IAAnC,CAFT;;IAIA,OAAOuB,SAAP;EACD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EArCE;;EAwCAnK,MAAM,CAACsK,sBAAP,GAAgC,SAASA,sBAAT,GAAkC;IAChE,IAAI/J,KAAK,GAAG,KAAKT,MAAL,CAAYK,KAAxB;IACA,IAAImB,IAAI,GAAG,KAAKpB,SAAL,EAAX;;IAEA,IAAIxB,iBAAiB,CAAC4C,IAAI,CAAChC,KAAN,CAAjB,KAAkCiC,SAAtC,EAAiD;MAC/C,OAAOD,IAAP;IACD;;IAED,MAAM,KAAKH,UAAL,CAAgBZ,KAAhB,CAAN;EACD,CATD,CASE;;EAEF;AACF;AACA;AACA;EAdE;;EAiBAP,MAAM,CAACM,GAAP,GAAa,SAASA,GAAT,CAAaiK,UAAb,EAAyB;IACpC,IAAIC,eAAJ;;IAEA,IAAI,CAAC,CAACA,eAAe,GAAG,KAAKzK,QAAxB,MAAsC,IAAtC,IAA8CyK,eAAe,KAAK,KAAK,CAAvE,GAA2E,KAAK,CAAhF,GAAoFA,eAAe,CAACC,UAArG,MAAqH,IAAzH,EAA+H;MAC7H,OAAO,IAAIlM,QAAJ,CAAagM,UAAb,EAAyB,KAAKzK,MAAL,CAAY4K,SAArC,EAAgD,KAAK5K,MAAL,CAAYhB,MAA5D,CAAP;IACD;EACF;EACD;AACF;AACA;EATE;;EAYAkB,MAAM,CAACY,IAAP,GAAc,SAASA,IAAT,CAAcP,IAAd,EAAoB;IAChC,OAAO,KAAKP,MAAL,CAAYK,KAAZ,CAAkBE,IAAlB,KAA2BA,IAAlC;EACD;EACD;AACF;AACA;AACA;EANE;;EASAL,MAAM,CAACZ,WAAP,GAAqB,SAASA,WAAT,CAAqBiB,IAArB,EAA2B;IAC9C,IAAIF,KAAK,GAAG,KAAKL,MAAL,CAAYK,KAAxB;;IAEA,IAAIA,KAAK,CAACE,IAAN,KAAeA,IAAnB,EAAyB;MACvB,KAAKP,MAAL,CAAY+E,OAAZ;;MAEA,OAAO1E,KAAP;IACD;;IAED,MAAM9B,WAAW,CAAC,KAAKyB,MAAL,CAAYhB,MAAb,EAAqBqB,KAAK,CAACI,KAA3B,EAAkC,YAAYV,MAAZ,CAAmB8K,gBAAgB,CAACtK,IAAD,CAAnC,EAA2C,UAA3C,EAAuDR,MAAvD,CAA8D+K,YAAY,CAACzK,KAAD,CAA1E,EAAmF,GAAnF,CAAlC,CAAjB;EACD;EACD;AACF;AACA;AACA;EAdE;;EAiBAH,MAAM,CAACyC,mBAAP,GAA6B,SAASA,mBAAT,CAA6BpC,IAA7B,EAAmC;IAC9D,IAAIF,KAAK,GAAG,KAAKL,MAAL,CAAYK,KAAxB;;IAEA,IAAIA,KAAK,CAACE,IAAN,KAAeA,IAAnB,EAAyB;MACvB,KAAKP,MAAL,CAAY+E,OAAZ;;MAEA,OAAO1E,KAAP;IACD;;IAED,OAAOoB,SAAP;EACD;EACD;AACF;AACA;AACA;EAdE;;EAiBAvB,MAAM,CAACsE,aAAP,GAAuB,SAASA,aAAT,CAAuBhF,KAAvB,EAA8B;IACnD,IAAIa,KAAK,GAAG,KAAKL,MAAL,CAAYK,KAAxB;;IAEA,IAAIA,KAAK,CAACE,IAAN,KAAe5B,SAAS,CAAC2B,IAAzB,IAAiCD,KAAK,CAACb,KAAN,KAAgBA,KAArD,EAA4D;MAC1D,KAAKQ,MAAL,CAAY+E,OAAZ;IACD,CAFD,MAEO;MACL,MAAMxG,WAAW,CAAC,KAAKyB,MAAL,CAAYhB,MAAb,EAAqBqB,KAAK,CAACI,KAA3B,EAAkC,cAAcV,MAAd,CAAqBP,KAArB,EAA4B,YAA5B,EAA0CO,MAA1C,CAAiD+K,YAAY,CAACzK,KAAD,CAA7D,EAAsE,GAAtE,CAAlC,CAAjB;IACD;EACF;EACD;AACF;AACA;AACA;EAZE;;EAeAH,MAAM,CAAC+D,qBAAP,GAA+B,SAASA,qBAAT,CAA+BzE,KAA/B,EAAsC;IACnE,IAAIa,KAAK,GAAG,KAAKL,MAAL,CAAYK,KAAxB;;IAEA,IAAIA,KAAK,CAACE,IAAN,KAAe5B,SAAS,CAAC2B,IAAzB,IAAiCD,KAAK,CAACb,KAAN,KAAgBA,KAArD,EAA4D;MAC1D,KAAKQ,MAAL,CAAY+E,OAAZ;;MAEA,OAAO,IAAP;IACD;;IAED,OAAO,KAAP;EACD;EACD;AACF;AACA;AACA;EAdE;;EAiBA7E,MAAM,CAACmB,UAAP,GAAoB,SAASA,UAAT,CAAoB0J,OAApB,EAA6B;IAC/C,IAAI1K,KAAK,GAAG0K,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyCA,OAAzC,GAAmD,KAAK/K,MAAL,CAAYK,KAA3E;IACA,OAAO9B,WAAW,CAAC,KAAKyB,MAAL,CAAYhB,MAAb,EAAqBqB,KAAK,CAACI,KAA3B,EAAkC,cAAcV,MAAd,CAAqB+K,YAAY,CAACzK,KAAD,CAAjC,EAA0C,GAA1C,CAAlC,CAAlB;EACD;EACD;AACF;AACA;AACA;AACA;AACA;EATE;;EAYAH,MAAM,CAACyF,GAAP,GAAa,SAASA,GAAT,CAAaqF,QAAb,EAAuBC,OAAvB,EAAgCC,SAAhC,EAA2C;IACtD,KAAK5L,WAAL,CAAiB0L,QAAjB;IACA,IAAIG,KAAK,GAAG,EAAZ;;IAEA,OAAO,CAAC,KAAKxI,mBAAL,CAAyBuI,SAAzB,CAAR,EAA6C;MAC3CC,KAAK,CAAChF,IAAN,CAAW8E,OAAO,CAACG,IAAR,CAAa,IAAb,CAAX;IACD;;IAED,OAAOD,KAAP;EACD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;EAhBE;;EAmBAjL,MAAM,CAACgC,YAAP,GAAsB,SAASA,YAAT,CAAsB8I,QAAtB,EAAgCC,OAAhC,EAAyCC,SAAzC,EAAoD;IACxE,IAAI,KAAKvI,mBAAL,CAAyBqI,QAAzB,CAAJ,EAAwC;MACtC,IAAIG,KAAK,GAAG,EAAZ;;MAEA,GAAG;QACDA,KAAK,CAAChF,IAAN,CAAW8E,OAAO,CAACG,IAAR,CAAa,IAAb,CAAX;MACD,CAFD,QAES,CAAC,KAAKzI,mBAAL,CAAyBuI,SAAzB,CAFV;;MAIA,OAAOC,KAAP;IACD;;IAED,OAAO,EAAP;EACD;EACD;AACF;AACA;AACA;AACA;AACA;EAlBE;;EAqBAjL,MAAM,CAACU,IAAP,GAAc,SAASA,IAAT,CAAcoK,QAAd,EAAwBC,OAAxB,EAAiCC,SAAjC,EAA4C;IACxD,KAAK5L,WAAL,CAAiB0L,QAAjB;IACA,IAAIG,KAAK,GAAG,EAAZ;;IAEA,GAAG;MACDA,KAAK,CAAChF,IAAN,CAAW8E,OAAO,CAACG,IAAR,CAAa,IAAb,CAAX;IACD,CAFD,QAES,CAAC,KAAKzI,mBAAL,CAAyBuI,SAAzB,CAFV;;IAIA,OAAOC,KAAP;EACD,CATD;;EAWA,OAAOhM,MAAP;AACD,CA37CyB,EAA1B;AA47CA;AACA;AACA;;;AAGA,SAAS2L,YAAT,CAAsBzK,KAAtB,EAA6B;EAC3B,IAAIb,KAAK,GAAGa,KAAK,CAACb,KAAlB;EACA,OAAOqL,gBAAgB,CAACxK,KAAK,CAACE,IAAP,CAAhB,IAAgCf,KAAK,IAAI,IAAT,GAAgB,MAAMO,MAAN,CAAaP,KAAb,EAAoB,IAApB,CAAhB,GAA4C,EAA5E,CAAP;AACD;AACD;AACA;AACA;;;AAGA,SAASqL,gBAAT,CAA0BtK,IAA1B,EAAgC;EAC9B,OAAOzB,qBAAqB,CAACyB,IAAD,CAArB,GAA8B,KAAKR,MAAL,CAAYQ,IAAZ,EAAkB,IAAlB,CAA9B,GAAwDA,IAA/D;AACD"},"metadata":{},"sourceType":"module"}