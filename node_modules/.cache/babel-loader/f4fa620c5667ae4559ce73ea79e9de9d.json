{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nimport { SYMBOL_ASYNC_ITERATOR } from \"../polyfills/symbols.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport { addPath, pathToArray } from \"../jsutils/Path.mjs\";\nimport { GraphQLError } from \"../error/GraphQLError.mjs\";\nimport { locatedError } from \"../error/locatedError.mjs\";\nimport { assertValidExecutionArguments, buildExecutionContext, buildResolveInfo, collectFields, execute, getFieldDef, resolveFieldValueOrError } from \"../execution/execute.mjs\";\nimport { getOperationRootType } from \"../utilities/getOperationRootType.mjs\";\nimport mapAsyncIterator from \"./mapAsyncIterator.mjs\";\nexport function subscribe(argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver) {\n  /* eslint-enable no-redeclare */\n  // Extract arguments from object args if provided.\n  return arguments.length === 1 ? subscribeImpl(argsOrSchema) : subscribeImpl({\n    schema: argsOrSchema,\n    document: document,\n    rootValue: rootValue,\n    contextValue: contextValue,\n    variableValues: variableValues,\n    operationName: operationName,\n    fieldResolver: fieldResolver,\n    subscribeFieldResolver: subscribeFieldResolver\n  });\n}\n/**\n * This function checks if the error is a GraphQLError. If it is, report it as\n * an ExecutionResult, containing only errors and no data. Otherwise treat the\n * error as a system-class error and re-throw it.\n */\n\nfunction reportGraphQLError(error) {\n  if (error instanceof GraphQLError) {\n    return {\n      errors: [error]\n    };\n  }\n\n  throw error;\n}\n\nfunction subscribeImpl(args) {\n  var schema = args.schema,\n      document = args.document,\n      rootValue = args.rootValue,\n      contextValue = args.contextValue,\n      variableValues = args.variableValues,\n      operationName = args.operationName,\n      fieldResolver = args.fieldResolver,\n      subscribeFieldResolver = args.subscribeFieldResolver;\n  var sourcePromise = createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, subscribeFieldResolver); // For each payload yielded from a subscription, map it over the normal\n  // GraphQL `execute` function, with `payload` as the rootValue.\n  // This implements the \"MapSourceToResponseEvent\" algorithm described in\n  // the GraphQL specification. The `execute` function provides the\n  // \"ExecuteSubscriptionEvent\" algorithm, as it is nearly identical to the\n  // \"ExecuteQuery\" algorithm, for which `execute` is also used.\n\n  var mapSourceToResponse = function mapSourceToResponse(payload) {\n    return execute({\n      schema: schema,\n      document: document,\n      rootValue: payload,\n      contextValue: contextValue,\n      variableValues: variableValues,\n      operationName: operationName,\n      fieldResolver: fieldResolver\n    });\n  }; // Resolve the Source Stream, then map every source value to a\n  // ExecutionResult value as described above.\n\n\n  return sourcePromise.then(function (resultOrStream) {\n    return (// Note: Flow can't refine isAsyncIterable, so explicit casts are used.\n      isAsyncIterable(resultOrStream) ? mapAsyncIterator(resultOrStream, mapSourceToResponse, reportGraphQLError) : resultOrStream\n    );\n  });\n}\n/**\n * Implements the \"CreateSourceEventStream\" algorithm described in the\n * GraphQL specification, resolving the subscription source event stream.\n *\n * Returns a Promise which resolves to either an AsyncIterable (if successful)\n * or an ExecutionResult (error). The promise will be rejected if the schema or\n * other arguments to this function are invalid, or if the resolved event stream\n * is not an async iterable.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with\n * descriptive errors and no data will be returned.\n *\n * If the the source stream could not be created due to faulty subscription\n * resolver logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to the AsyncIterable for the\n * event stream returned by the resolver.\n *\n * A Source Event Stream represents a sequence of events, each of which triggers\n * a GraphQL execution for that event.\n *\n * This may be useful when hosting the stateful subscription service in a\n * different process or machine than the stateless GraphQL execution engine,\n * or otherwise separating these two steps. For more on this, see the\n * \"Supporting Subscriptions at Scale\" information in the GraphQL specification.\n */\n\n\nexport function createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver) {\n  // If arguments are missing or incorrectly typed, this is an internal\n  // developer mistake which should throw an early error.\n  assertValidExecutionArguments(schema, document, variableValues);\n\n  try {\n    var _fieldDef$subscribe; // If a valid context cannot be created due to incorrect arguments,\n    // this will throw an error.\n\n\n    var exeContext = buildExecutionContext(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver); // Return early errors if execution context failed.\n\n    if (Array.isArray(exeContext)) {\n      return Promise.resolve({\n        errors: exeContext\n      });\n    }\n\n    var type = getOperationRootType(schema, exeContext.operation);\n    var fields = collectFields(exeContext, type, exeContext.operation.selectionSet, Object.create(null), Object.create(null));\n    var responseNames = Object.keys(fields);\n    var responseName = responseNames[0];\n    var fieldNodes = fields[responseName];\n    var fieldNode = fieldNodes[0];\n    var fieldName = fieldNode.name.value;\n    var fieldDef = getFieldDef(schema, type, fieldName);\n\n    if (!fieldDef) {\n      throw new GraphQLError(\"The subscription field \\\"\".concat(fieldName, \"\\\" is not defined.\"), fieldNodes);\n    } // Call the `subscribe()` resolver or the default resolver to produce an\n    // AsyncIterable yielding raw payloads.\n\n\n    var resolveFn = (_fieldDef$subscribe = fieldDef.subscribe) !== null && _fieldDef$subscribe !== void 0 ? _fieldDef$subscribe : exeContext.fieldResolver;\n    var path = addPath(undefined, responseName, type.name);\n    var info = buildResolveInfo(exeContext, fieldDef, fieldNodes, type, path); // resolveFieldValueOrError implements the \"ResolveFieldEventStream\"\n    // algorithm from GraphQL specification. It differs from\n    // \"ResolveFieldValue\" due to providing a different `resolveFn`.\n\n    var result = resolveFieldValueOrError(exeContext, fieldDef, fieldNodes, resolveFn, rootValue, info); // Coerce to Promise for easier error handling and consistent return type.\n\n    return Promise.resolve(result).then(function (eventStream) {\n      // If eventStream is an Error, rethrow a located error.\n      if (eventStream instanceof Error) {\n        return {\n          errors: [locatedError(eventStream, fieldNodes, pathToArray(path))]\n        };\n      } // Assert field returned an event stream, otherwise yield an error.\n\n\n      if (isAsyncIterable(eventStream)) {\n        // Note: isAsyncIterable above ensures this will be correct.\n        return eventStream;\n      }\n\n      throw new Error('Subscription field must return Async Iterable. ' + \"Received: \".concat(inspect(eventStream), \".\"));\n    });\n  } catch (error) {\n    // As with reportGraphQLError above, if the error is a GraphQLError, report\n    // it as an ExecutionResult; otherwise treat it as a system-class error and\n    // re-throw it.\n    return error instanceof GraphQLError ? Promise.resolve({\n      errors: [error]\n    }) : Promise.reject(error);\n  }\n}\n/**\n * Returns true if the provided object implements the AsyncIterator protocol via\n * either implementing a `Symbol.asyncIterator` or `\"@@asyncIterator\"` method.\n */\n\nfunction isAsyncIterable(maybeAsyncIterable) {\n  if (maybeAsyncIterable == null || _typeof(maybeAsyncIterable) !== 'object') {\n    return false;\n  }\n\n  return typeof maybeAsyncIterable[SYMBOL_ASYNC_ITERATOR] === 'function';\n}","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","SYMBOL_ASYNC_ITERATOR","inspect","addPath","pathToArray","GraphQLError","locatedError","assertValidExecutionArguments","buildExecutionContext","buildResolveInfo","collectFields","execute","getFieldDef","resolveFieldValueOrError","getOperationRootType","mapAsyncIterator","subscribe","argsOrSchema","document","rootValue","contextValue","variableValues","operationName","fieldResolver","subscribeFieldResolver","arguments","length","subscribeImpl","schema","reportGraphQLError","error","errors","args","sourcePromise","createSourceEventStream","mapSourceToResponse","payload","then","resultOrStream","isAsyncIterable","_fieldDef$subscribe","exeContext","Array","isArray","Promise","resolve","type","operation","fields","selectionSet","Object","create","responseNames","keys","responseName","fieldNodes","fieldNode","fieldName","name","value","fieldDef","concat","resolveFn","path","undefined","info","result","eventStream","Error","reject","maybeAsyncIterable"],"sources":["/Users/anubhavgupta/Documents/react_learning/graphql-react/relay-learning/node_modules/graphql/subscription/subscribe.mjs"],"sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport { SYMBOL_ASYNC_ITERATOR } from \"../polyfills/symbols.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport { addPath, pathToArray } from \"../jsutils/Path.mjs\";\nimport { GraphQLError } from \"../error/GraphQLError.mjs\";\nimport { locatedError } from \"../error/locatedError.mjs\";\nimport { assertValidExecutionArguments, buildExecutionContext, buildResolveInfo, collectFields, execute, getFieldDef, resolveFieldValueOrError } from \"../execution/execute.mjs\";\nimport { getOperationRootType } from \"../utilities/getOperationRootType.mjs\";\nimport mapAsyncIterator from \"./mapAsyncIterator.mjs\";\nexport function subscribe(argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver) {\n  /* eslint-enable no-redeclare */\n  // Extract arguments from object args if provided.\n  return arguments.length === 1 ? subscribeImpl(argsOrSchema) : subscribeImpl({\n    schema: argsOrSchema,\n    document: document,\n    rootValue: rootValue,\n    contextValue: contextValue,\n    variableValues: variableValues,\n    operationName: operationName,\n    fieldResolver: fieldResolver,\n    subscribeFieldResolver: subscribeFieldResolver\n  });\n}\n/**\n * This function checks if the error is a GraphQLError. If it is, report it as\n * an ExecutionResult, containing only errors and no data. Otherwise treat the\n * error as a system-class error and re-throw it.\n */\n\nfunction reportGraphQLError(error) {\n  if (error instanceof GraphQLError) {\n    return {\n      errors: [error]\n    };\n  }\n\n  throw error;\n}\n\nfunction subscribeImpl(args) {\n  var schema = args.schema,\n      document = args.document,\n      rootValue = args.rootValue,\n      contextValue = args.contextValue,\n      variableValues = args.variableValues,\n      operationName = args.operationName,\n      fieldResolver = args.fieldResolver,\n      subscribeFieldResolver = args.subscribeFieldResolver;\n  var sourcePromise = createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, subscribeFieldResolver); // For each payload yielded from a subscription, map it over the normal\n  // GraphQL `execute` function, with `payload` as the rootValue.\n  // This implements the \"MapSourceToResponseEvent\" algorithm described in\n  // the GraphQL specification. The `execute` function provides the\n  // \"ExecuteSubscriptionEvent\" algorithm, as it is nearly identical to the\n  // \"ExecuteQuery\" algorithm, for which `execute` is also used.\n\n  var mapSourceToResponse = function mapSourceToResponse(payload) {\n    return execute({\n      schema: schema,\n      document: document,\n      rootValue: payload,\n      contextValue: contextValue,\n      variableValues: variableValues,\n      operationName: operationName,\n      fieldResolver: fieldResolver\n    });\n  }; // Resolve the Source Stream, then map every source value to a\n  // ExecutionResult value as described above.\n\n\n  return sourcePromise.then(function (resultOrStream) {\n    return (// Note: Flow can't refine isAsyncIterable, so explicit casts are used.\n      isAsyncIterable(resultOrStream) ? mapAsyncIterator(resultOrStream, mapSourceToResponse, reportGraphQLError) : resultOrStream\n    );\n  });\n}\n/**\n * Implements the \"CreateSourceEventStream\" algorithm described in the\n * GraphQL specification, resolving the subscription source event stream.\n *\n * Returns a Promise which resolves to either an AsyncIterable (if successful)\n * or an ExecutionResult (error). The promise will be rejected if the schema or\n * other arguments to this function are invalid, or if the resolved event stream\n * is not an async iterable.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with\n * descriptive errors and no data will be returned.\n *\n * If the the source stream could not be created due to faulty subscription\n * resolver logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to the AsyncIterable for the\n * event stream returned by the resolver.\n *\n * A Source Event Stream represents a sequence of events, each of which triggers\n * a GraphQL execution for that event.\n *\n * This may be useful when hosting the stateful subscription service in a\n * different process or machine than the stateless GraphQL execution engine,\n * or otherwise separating these two steps. For more on this, see the\n * \"Supporting Subscriptions at Scale\" information in the GraphQL specification.\n */\n\n\nexport function createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver) {\n  // If arguments are missing or incorrectly typed, this is an internal\n  // developer mistake which should throw an early error.\n  assertValidExecutionArguments(schema, document, variableValues);\n\n  try {\n    var _fieldDef$subscribe;\n\n    // If a valid context cannot be created due to incorrect arguments,\n    // this will throw an error.\n    var exeContext = buildExecutionContext(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver); // Return early errors if execution context failed.\n\n    if (Array.isArray(exeContext)) {\n      return Promise.resolve({\n        errors: exeContext\n      });\n    }\n\n    var type = getOperationRootType(schema, exeContext.operation);\n    var fields = collectFields(exeContext, type, exeContext.operation.selectionSet, Object.create(null), Object.create(null));\n    var responseNames = Object.keys(fields);\n    var responseName = responseNames[0];\n    var fieldNodes = fields[responseName];\n    var fieldNode = fieldNodes[0];\n    var fieldName = fieldNode.name.value;\n    var fieldDef = getFieldDef(schema, type, fieldName);\n\n    if (!fieldDef) {\n      throw new GraphQLError(\"The subscription field \\\"\".concat(fieldName, \"\\\" is not defined.\"), fieldNodes);\n    } // Call the `subscribe()` resolver or the default resolver to produce an\n    // AsyncIterable yielding raw payloads.\n\n\n    var resolveFn = (_fieldDef$subscribe = fieldDef.subscribe) !== null && _fieldDef$subscribe !== void 0 ? _fieldDef$subscribe : exeContext.fieldResolver;\n    var path = addPath(undefined, responseName, type.name);\n    var info = buildResolveInfo(exeContext, fieldDef, fieldNodes, type, path); // resolveFieldValueOrError implements the \"ResolveFieldEventStream\"\n    // algorithm from GraphQL specification. It differs from\n    // \"ResolveFieldValue\" due to providing a different `resolveFn`.\n\n    var result = resolveFieldValueOrError(exeContext, fieldDef, fieldNodes, resolveFn, rootValue, info); // Coerce to Promise for easier error handling and consistent return type.\n\n    return Promise.resolve(result).then(function (eventStream) {\n      // If eventStream is an Error, rethrow a located error.\n      if (eventStream instanceof Error) {\n        return {\n          errors: [locatedError(eventStream, fieldNodes, pathToArray(path))]\n        };\n      } // Assert field returned an event stream, otherwise yield an error.\n\n\n      if (isAsyncIterable(eventStream)) {\n        // Note: isAsyncIterable above ensures this will be correct.\n        return eventStream;\n      }\n\n      throw new Error('Subscription field must return Async Iterable. ' + \"Received: \".concat(inspect(eventStream), \".\"));\n    });\n  } catch (error) {\n    // As with reportGraphQLError above, if the error is a GraphQLError, report\n    // it as an ExecutionResult; otherwise treat it as a system-class error and\n    // re-throw it.\n    return error instanceof GraphQLError ? Promise.resolve({\n      errors: [error]\n    }) : Promise.reject(error);\n  }\n}\n/**\n * Returns true if the provided object implements the AsyncIterator protocol via\n * either implementing a `Symbol.asyncIterator` or `\"@@asyncIterator\"` method.\n */\n\nfunction isAsyncIterable(maybeAsyncIterable) {\n  if (maybeAsyncIterable == null || _typeof(maybeAsyncIterable) !== 'object') {\n    return false;\n  }\n\n  return typeof maybeAsyncIterable[SYMBOL_ASYNC_ITERATOR] === 'function';\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}